<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莫克力学习博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mrdouhua.github.io/"/>
  <updated>2020-06-30T12:28:27.156Z</updated>
  <id>https://mrdouhua.github.io/</id>
  
  <author>
    <name>莫克力</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>原生js封装ajax</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/</id>
    <published>2020-06-30T12:27:21.630Z</published>
    <updated>2020-06-30T12:28:27.156Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function ajax (options) &#123;</span><br><span class="line">    let xhr &#x3D; null</span><br><span class="line">    if ((window.XMLHttpRequest) &#123;</span><br><span class="line">        xhr &#x3D; new XMLHttpRequest()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; IE6及其以下版本</span><br><span class="line">        xhr &#x3D; new ActiveXObjcet(&#39;Microsoft.XMLHTTP&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">        if(xhr.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">            let status &#x3D; xhr.status;</span><br><span class="line">            if ((status &gt;&#x3D; 200 &amp;&amp; status &lt; 300) || status &#x3D;&#x3D;&#x3D; 304) &#123;</span><br><span class="line">                options.success &amp;&amp; options.success()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                options.error &amp;&amp; options.error()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let type &#x3D; (options.type || &#39;GET&#39;).toUpperCase() &#x2F;&#x2F; 转为大写</span><br><span class="line">    if (type &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;</span><br><span class="line">        let url &#x3D; xhr.url + &#39;?&#39; + formatParams(option.data)</span><br><span class="line">        xhr.open(type, url, true)</span><br><span class="line">        xhr.send(null)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        xhr.open(type, url, true)</span><br><span class="line">        &#x2F;&#x2F;设置提交时的内容类型</span><br><span class="line">        xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&#39;);</span><br><span class="line">        xhr.send(option.data)</span><br><span class="line">    &#125;</span><br><span class="line">    function formatParams (data) &#123;</span><br><span class="line">        var arr &#x3D; [];</span><br><span class="line">        for(var name in data) &#123;</span><br><span class="line">          arr.push(name + &#39;&#x3D;&#39; + data[name]);</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 添加一个随机数，防止缓存</span><br><span class="line">        arr.push(&#39;v&#x3D;&#39; + Math.floor(Math.random() * 10000 + 500));</span><br><span class="line">        return arr.join(&#39;&amp;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2020-06-30T11:48:17.691Z</published>
    <updated>2020-06-30T11:48:51.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>解释：当持续触发某事件时，一定时间间隔内没有再触发事件时，事件处理函数才会执行一次，如果设定的时间间隔到来之前，又一次触发了事件，就重新开始延时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">    let timeout &#x3D; null &#x2F;&#x2F; 借助闭包</span><br><span class="line">    return function () &#123;</span><br><span class="line">        if (timeout) clearTimeout(timeout)</span><br><span class="line">        timeout &#x3D; setTimeout(fn, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function handle() &#123;  </span><br><span class="line">    console.log(Math.random())</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&#39;scroll&#39;, debounce(handle, 1000))</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>当持续触发事件时，有规律的每隔一个时间间隔执行一次事件处理函数。如果规定时间内触发了事件，不执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function throttle (fn, wait) &#123;</span><br><span class="line">    let flag &#x3D; false</span><br><span class="line">    return function () &#123;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        flag &#x3D; true</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">          flag &#x3D; false</span><br><span class="line">          fn()</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h2&gt;&lt;p&gt;解释：当持续触发某事件时，一定时间间隔内没有再触发事件时，事件处理函数才会执行一次，如果设定的时间间隔到来之前，又一次触发了事件，就重新开始
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSS基本布局篇</title>
    <link href="https://mrdouhua.github.io/2020/06/30/CSS%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E7%AF%87/"/>
    <id>https://mrdouhua.github.io/2020/06/30/CSS%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E7%AF%87/</id>
    <published>2020-06-30T02:26:57.811Z</published>
    <updated>2020-06-30T02:27:26.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>很多方法都会受浮动影响</p><ul><li><p>单行已知宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text-align:center;</span><br><span class="line">inline-height: 50px;</span><br></pre></td></tr></table></figure></li><li><p>已知字元素宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    position: reletive;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute&#x2F;relative;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    margin: -50px 0 0 -50px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>margin:auto;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    position: reletive;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    tight: 0;</span><br><span class="line">    b0ttom: 0;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>未知宽高<br>用css3 transform: translate(-50%, -50%);</p></li><li><p>table-cell表格实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: table-cell;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">text-align: center;</span><br></pre></td></tr></table></figure></li></ul><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><ul><li>浮动<br>left左浮动，right不浮动，margin/padding-left</li><li>绝对定位<br>方式和浮动一样</li><li>表格布局<br>wrap: table, child:table-cell</li><li>flex布局</li></ul><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>1、将middle首先放在container的子元素第一个，然后是left，right,同时设置三者float:left；</p><p>2、middle要自适应，需要设置width:100%；让left部分和middle处于一行，要是用margin-left:-100%;</p><p>3、此时left部分会遮盖middle的内容，将middle部分收缩起来，设置其父元素container内边距，padding：0 200px;</p><p>4、left部分内容随同middle收缩，占据middle一部分，需要设置left部分使用相对定位，独立于middle，left:-200px;</p><p>5、同理right部分放置middle右部分，需要设置其相对定位、宽度和margin-left、right值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;圣杯布局&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">　　body&#123;</span><br><span class="line">　　　　margin:auto;</span><br><span class="line">　　　　text-align: center;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.container&#123;</span><br><span class="line">　　　　overflow: hidden;</span><br><span class="line">　　　　margin:10px 0;</span><br><span class="line">　　　　padding: 0 200px 0 205px;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.left&#123;</span><br><span class="line">　　　　float: left;</span><br><span class="line">　　　　position: relative;</span><br><span class="line">　　　　margin-left: -100%;</span><br><span class="line">　　　　left: -210px;</span><br><span class="line">　　　　width: 205px;</span><br><span class="line">　　　　background-color:grey;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.middle&#123;</span><br><span class="line">　　　　float: left;</span><br><span class="line">　　　　width: 100%;</span><br><span class="line">　　　　background-color: red;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.right&#123;</span><br><span class="line">　　　　right: -210px;</span><br><span class="line">　　　　margin-left: -205px;</span><br><span class="line">　　　　width: 200px;</span><br><span class="line">　　　　float: left;</span><br><span class="line">　　　　position: relative;</span><br><span class="line">　　　　background-color: grey;</span><br><span class="line">　　&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">　　&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">　　　　&lt;div class&#x3D;&quot;middle&quot;&gt;middle&lt;&#x2F;div&gt;</span><br><span class="line">　　　　&lt;div class&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt;</span><br><span class="line">　　　　&lt;div class&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt;</span><br><span class="line">　　&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">## 双飞翼布局</span><br><span class="line">1、将middle首先放在container的子元素第一个，然后是left，right,同时设置三者float:left；</span><br><span class="line"></span><br><span class="line">2、middle要自适应，需要设置width:100%；让left部分和middle处于一行，要是用margin-left:-100%;，right使用margin-left:-190px;</span><br><span class="line"></span><br><span class="line">3、此时middle的内容被覆盖，要把middle的内容拉出来，除了使用外围container的padding，还可以考虑使用margin，给middle增加一个内层div -- middle_content, 然后设置 margin:0 200px</span><br></pre></td></tr></table></figure><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="莫克力学习博客" type="application/atom+xml"></head><body>    <div class="wrapper">        <div class="main">            <div class="inner">                main            </div>        </div>        <div class="left">left</div>        <div class="right">right</div>    </div>     <style>        .main,.left,.right{            height: 100px;            float: left;        }        .main{            width: 100%;            background-color: aqua;        }        .left{            width:120px;            margin-left: -100%;            background-color:cornflowerblue;        }        .right{            width: 120px;            margin-left: -120px;            background-color: cadetblue;        }        .inner{            margin-left:120px;            margin-right: 120px;        }     </style></body>```## flex布局- display:flex/inline-flex  - flex-direction  主轴方向  - flex-wrap  是否换行    - nowrap 不换行    - wrap  换行    - wrap-reverse  换行，第一行在上方  - flex-flow  是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap  - justify-content  水平方向排列    - flex-start    - flex-end    - center    - space-between    - space-around  - align-items  垂直方向      - flex-start    - flex-end    - center    - baseline    - stretch  - align-content  根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<ul><li>子元素的属性<ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;水平垂直居中&quot;&gt;&lt;a href=&quot;#水平垂直居中&quot; class=&quot;headerlink&quot; title=&quot;水平垂直居中&quot;&gt;&lt;/a&gt;水平垂直居中&lt;/h2&gt;&lt;p&gt;很多方法都会受浮动影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单行已知宽高&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>webpack学习</title>
    <link href="https://mrdouhua.github.io/2020/06/30/webpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mrdouhua.github.io/2020/06/30/webpack%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-30T02:26:23.620Z</published>
    <updated>2020-06-30T02:26:44.601Z</updated>
    
    <content type="html"><![CDATA[<p>webpack概念</p><ul><li>entry</li><li>output</li><li>loader</li><li>plugin</li><li>optimization // webpack4</li><li>externals</li><li>mode<br>development 或 production</li></ul><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>单页面入口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: &#39;.&#x2F;src&#x2F;pageOne&#x2F;index.js&#39;,</span><br><span class="line">    pageTwo: &#39;.&#x2F;src&#x2F;pageTwo&#x2F;index.js&#39;,</span><br><span class="line">    pageThree: &#39;.&#x2F;src&#x2F;pageThree&#x2F;index.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多页面片</p><blockquote><p>filename 用于输出文件的文件名。<br>目标输出目录 path 的绝对路径。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: &#39;.&#x2F;src&#x2F;pageOne&#x2F;index.js&#39;,</span><br><span class="line">    pageTwo: &#39;.&#x2F;src&#x2F;pageTwo&#x2F;index.js&#39;,</span><br><span class="line">    pageThree: &#39;.&#x2F;src&#x2F;pageThree&#x2F;index.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;bundle.js&#39;,</span><br><span class="line">    path: &#39;&#x2F;home&#x2F;proj&#x2F;public&#x2F;assets&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; config;</span><br></pre></td></tr></table></figure><p>多页面片入口起点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;app.js&#39;,</span><br><span class="line">    search: &#39;.&#x2F;src&#x2F;search.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    path: __dirname + &#39;&#x2F;dist&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mode-模式"><a href="#mode-模式" class="headerlink" title="mode 模式"></a>mode 模式</h2><p>提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">或者从 CLI 参数中传递：  </span><br><span class="line">webpack --mode&#x3D;production</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: &#x2F;\.css$&#x2F;, use: &#39;css-loader&#39; &#125;,</span><br><span class="line">      &#123; test: &#x2F;\.ts$&#x2F;, use: &#39;ts-loader&#39; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><p>插件目的在于解决 loader 无法实现的其他事  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &#39;.&#x2F;src&#x2F;index.html&#39;&#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="构建目标-targets"><a href="#构建目标-targets" class="headerlink" title="构建目标(targets)"></a>构建目标(targets)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  target: &#39;node&#39; &#x2F;&#x2F; 默认为web</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="devServer本地服务器"><a href="#devServer本地服务器" class="headerlink" title="devServer本地服务器"></a>devServer本地服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">        contentBase: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 本地服务器所加载文件的目录</span><br><span class="line">        port: &quot;8088&quot;,  &#x2F;&#x2F; 设置端口号为8088</span><br><span class="line">        inline: true, &#x2F;&#x2F; 文件修改后实时刷新</span><br><span class="line">        historyApiFallback: true, &#x2F;&#x2F;不跳转</span><br><span class="line">        hot: true &#x2F;&#x2F; 热更新</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h2><p>HMR  </p><h2 id="Source-Maps调试配置"><a href="#Source-Maps调试配置" class="headerlink" title="Source Maps调试配置"></a>Source Maps调试配置</h2><p>作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，Source Map就是用来解决这个问题的</p><h4 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h4><p>在任何模块文件内部，可以使用__dirname变量获取当前模块文件所在目录的完整绝对路径。  </p><p>配置：  </p><h4 id="configureWebpack"><a href="#configureWebpack" class="headerlink" title="configureWebpack"></a>configureWebpack</h4><blockquote><p>如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。<br>如果这个值是一个函数，则会接收被解析的配置作为参数。该函数既可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。  </p></blockquote><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>在浏览器运行时，webpack 用来连接模块化的应用程序的所有代码。runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。  </p><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>当编译器(compiler)开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为 “Manifest”，当完成打包并发送到浏览器时，会在运行时通过 Manifest 来解析和加载模块。无论你选择哪种模块语法，那些 import 或 require 语句现在都已经转换为 <strong>webpack_require</strong> 方法  </p><p>webpack.optimize.CommonsChunkPlugin来帮我们分离代码，将mainfest、第三方库包，业务代码独立成三个文件  </p><p>1.runtime</p><p>在浏览器运行时,webpack用来连接模块化的应用程序的所有代码 runtime包含:</p><p>在模块交互时,连接模块所需的加载和解析逻辑<br>包括浏览器中的已加载模块的连接,以及懒加载模块的执行逻辑  </p><p>2.manifest</p><p>manifest数据用来管理生成的index.html文件和bundle以及各种资源,把他们加载到浏览器中</p><p>当编译器开始执行、解析和映射应用程序,会保留所有模块的详细要点. 这个集合称为Manifest</p><p>打包完成发送到浏览器 运行时通过Manifest来解析和加载模块 import 或require语句转换为 webpack require 方法 此方法指向模块标识符 通过manifest 中的数据 runtime 将能够查询模块标识符,检索出背后对应的模块</p><h4 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h4><p>是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。</p><h2 id="webpack3和webpack4对比"><a href="#webpack3和webpack4对比" class="headerlink" title="webpack3和webpack4对比"></a>webpack3和webpack4对比</h2><p>1.替换插件 extract-text-webpack-plugin，使用 webpack4 推荐使用的插件mini-css-extract-plugin<br>2.在 webpack4 中不再支持 CommonsChunkPlugin，而是使用 splitChunks 替代  </p><ul><li>CommonsChunkPlugin 会提取一些我们不需要的代码  </li><li>它在异步模块上效率低下</li><li>splitChunks它不会打包不需要的模块</li><li>splitChunks对异步模块有效（默认情况下是打开的）<br>webpack 4 已经废除了 之前 UglifyJsPlugin,用 optimization.minimize 替代  <h2 id="vue-cli3使用"><a href="#vue-cli3使用" class="headerlink" title="vue-cli3使用"></a>vue-cli3使用</h2></li></ul><h2 id="webpack多页面片"><a href="#webpack多页面片" class="headerlink" title="webpack多页面片"></a>webpack多页面片</h2><p>webpack3/4大致差不多，只是部分插件不一样</p><ul><li>entry单页面片 ‘./src/index.html’，多页面片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;app.js&#39;,</span><br><span class="line">    search: &#39;.&#x2F;src&#x2F;search.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    path: __dirname + &#39;&#x2F;dist&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>htmlWebpackPlugins</li><li>使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;webpack概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;entry&lt;/li&gt;
&lt;li&gt;output&lt;/li&gt;
&lt;li&gt;loader&lt;/li&gt;
&lt;li&gt;plugin&lt;/li&gt;
&lt;li&gt;optimization // webpack4&lt;/li&gt;
&lt;li&gt;externals&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019腾讯前端技术大会----SSR学习</title>
    <link href="https://mrdouhua.github.io/2020/06/30/2019%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A----SSR%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mrdouhua.github.io/2020/06/30/2019%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A----SSR%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-30T02:19:10.659Z</published>
    <updated>2020-06-30T02:19:48.227Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>进入页面loading加载状态，页面白屏时间长<br>原因是客户端渲染：html 仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。  </p><p>前端渲染的方式起源于JavaScript的兴起，ajax的大热更是让前端渲染更加成熟，前端渲染真正意义上的实现了前后端分离，前端只专注于UI的开发，后端只专注于逻辑的开发，前后端交互只通过约定好的API来交互，后端提供json数据，前端循环json生成DOM插入到页面中去。 </p><p>好处： 网络传输数据量小、减少了服务器压力、前后端分离、局部刷新，无需每次请求完整页面、交互好可实现各种效果  </p><p>坏处：不利于SEO、爬虫看不到完整的程序源码、首屏渲染慢（渲染前需要下载一堆js和css等）  </p><h3 id="SSR是什么"><a href="#SSR是什么" class="headerlink" title="SSR是什么"></a>SSR是什么</h3><p>服务端渲染（SSR：server side render）<br>将页面通过服务器生成html字符串，再发送到浏览器</p><p>怎么理解SSR<br>首先，我们需要有一份同构代码，这部分代码和我们之前写的前端代码是基本一致的。然后，因为需要服务端渲染，所以服务端需要有一份同构代码打包后的js bundle，前端不必多说，天生需要一份。要注意的是，这两份是不同的bundle，因为server端和client端虽然都是做渲染工作，他们做的事情是有不同的，下面细说。然后经过中间的webpack打包后部署。接下来，请求到来，node server收到请求后，用server bundle作为入口拿到一份前端代码，render成html后返回给前端。前端收到后，就可以把预渲染的html展示给用户拉！！！就这么利索。但是前端还会去下载前端的bundle，然后以此为入口，激活后端返回的html，然后此时你的站点就完全可交互了！完美~  </p><p>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。</p><p>渲染：就是将数据和模版组装成html  </p><h3 id="SSR的优点与缺点"><a href="#SSR的优点与缺点" class="headerlink" title="SSR的优点与缺点"></a>SSR的优点与缺点</h3><ul><li>优点<ul><li>更利于SEO<ul><li>通过AJAX加载页面数据的，很难保证站内数据被SEO获取到</li><li>更好的SEO，我们可以将SEO的关键数据直接在后台就渲染成html，从而保证搜索引擎的爬虫能爬取到关键数据</li><li>由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li></ul></li><li>更利于首屏渲染  <ul><li>服务器端请求首屏数据而不是客户端请求首屏数据，服务器端在内网进行请求，速度更快。但是客户端处于不同的网络环境，导致时间差</li></ul></li></ul></li><li>缺点<ul><li>服务器压力大，考虑服务器端负载。</li><li>学习成本增大，需要学习构建设置和部署的更多要求</li><li>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</li></ul></li></ul><p>由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染 (SSR) 过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。</p><p>SSR与CSR对比<br>serverless如何解决SSR开发成本高的问题的<br>fass是什么，怎么使用<br>FaaS 可以将函数作为一个线上服务、远程计算服务，可以通过 API 执行、通过邮件执行、通过 Iot 执行，通过队列执行。你只需要写统一的函数就行了。<br>你要做的只是写下如下这样的函数，然后再用配置文件告诉服务器如何让他运行，就完事了，你的所有工作都在这个函数内完成。</p><p><img src="https://img-blog.csdnimg.cn/20190712222152121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzg0Mzc5,size_16,color_FFFFFF,t_70" alt="image"></p><h3 id="如何做到极致的SSR"><a href="#如何做到极致的SSR" class="headerlink" title="如何做到极致的SSR"></a>如何做到极致的SSR</h3><h3 id="是否需要使用SSR"><a href="#是否需要使用SSR" class="headerlink" title="是否需要使用SSR"></a>是否需要使用SSR</h3><p>这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。</p><h3 id="服务器端渲染-vs-预渲染-SSR-vs-Prerendering"><a href="#服务器端渲染-vs-预渲染-SSR-vs-Prerendering" class="headerlink" title="服务器端渲染 vs 预渲染 (SSR vs Prerendering)"></a>服务器端渲染 vs 预渲染 (SSR vs Prerendering)</h3><p>vue ssr解读<br>避免状态单例  </p><p>许多 webpack 特定功能不能直接在 Node.js 中运行（例如通过 file-loader 导入文件，通过 css-loader 导入 CSS）  </p><p>所以基本看法是，对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包 - 服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记。  </p><p>在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的”快照”，所以如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。  </p><p>使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation)，以避免 XSS 攻击。  </p><p>asyncData是干嘛用的？其实，这个函数是专门请求数据用的，你可能会问请求数据为什么不在beforeCreate或者created中完成，还要专门定义一个函数？虽然beforeCreate和created在服务端也会被执行（其他周期函数只会在客户端执行），但是我们都知道请求是异步的，这就导致请求发出后，数据还没返回，渲染就已经结束了，所以无法把 Ajax 返回的数据也一并渲染出来。因此需要想个办法，等到所有数据都返回后再渲染组件</p><p>在 2.3.2+ 的版本，你可以通过 this.$ssrContext 来直接访问组件中的服务器端渲染上下文(SSR context)  </p><p>如果您唯一关注的是SEO，那么随时都可以轻松使用预渲染。 </p><h3 id="流式渲染-Streaming"><a href="#流式渲染-Streaming" class="headerlink" title="流式渲染 (Streaming)"></a>流式渲染 (Streaming)</h3><p>对于 vue-server-renderer 的基本 renderer 和 bundle renderer 都提供开箱即用的流式渲染功能。所有你需要做的就是，用 renderToStream 替代 renderToString：  </p><h3 id="非NodeJs中使用SSR"><a href="#非NodeJs中使用SSR" class="headerlink" title="非NodeJs中使用SSR"></a>非NodeJs中使用SSR</h3><p>对于所有环境，必须要预先在环境中模拟 global 和 process 对象，以及将 process.env.VUE_ENV 设置为 “server” 和将 process.env.NODE_ENV 设置为 “development” 或 “production”。  </p><p>phpV8js中使用，V8Js是Google V8 Javascript引擎的PHP扩展，那这个插件是在php中模拟V8引擎，然后可以运行js代码  </p><p>process 对象：process对象是Node.js中非常重要的一个全局对象，它是一个与操作系统集成的对象，使用process我们可以进行许多与操作系统打交道的工作  </p><h4 id="serverless-与-faas"><a href="#serverless-与-faas" class="headerlink" title="serverless 与 faas"></a>serverless 与 faas</h4><p>Serverless架构<br>Serverless（无服务器架构）指的是由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发， 完全被第三方管理，其业务层面的状态则被开发者使用的数据库和存储资源所记录。  </p><h5 id="Serverless架构主要有以下特点："><a href="#Serverless架构主要有以下特点：" class="headerlink" title="Serverless架构主要有以下特点："></a>Serverless架构主要有以下特点：</h5><p>实现了细粒度的计算资源分配。<br>不需要预先分配资源。<br>具备真正意义上的高度扩容和弹性。<br>按需使用，按需计费。  </p><p>FaaS函数即服务？  </p><p>专注于单一责任与功能的小型功能块为基础，利用模组化的方式组合出复杂的大型应用程序<br>Function as a Services（FaaS）。而所谓的“函数”（Function）提供的是相比微服务更加细小的程序单元。例如用户的创建、读取等操作 </p><p>PaaS（Platform as a Service  </p><p>Q 一般SSR首次绘制(FP: First Paint)慢, 不能渐进式加载<br>A HTTP1.1 分块传输可以完美的解决这个问题<br>Transfer-Encoding: chunked<br>HTTP2:   数据帧  </p><p>Q SSR页面切换无法渐进式加载， 不能定义页面切换动画<br>A 无刷新切换：直出单页应用运用前端路由管理模块，页面无刷新切换的页面状态， 可自定义切换动效。<br>Q 怎么理解serveless和fass，按需执行、弹性伸缩是什么意思</p><p>Q 流式渲染与分块传输区别，二者分别是什么意思<br>依赖由组件生命周期钩子函数填充的上下文数据，则不建议使用流式传输模式  </p><p>Q 服务端只有beforeCreate 和 created两个生命周期吗<br>A 已证明 是的</p><p>Q1，如何应用到小雨伞中<br>Q2，相比于加载单页应用，我只需要加载当前页面的内容，而不需要像 React 或者 Vue 一样加载全部的 js 文件 </p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>vue ssr <a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">https://ssr.vuejs.org/zh/</a><br><a href="https://www.jianshu.com/p/b8cfa496b7ec" target="_blank" rel="noopener">https://www.jianshu.com/p/b8cfa496b7ec</a>  简书<br><a href="https://www.jdon.com/50088" target="_blank" rel="noopener">https://www.jdon.com/50088</a> SSR问题<br><a href="https://segmentfault.com/a/1190000015964813?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015964813?utm_source=tag-newest</a>  原理解读<br><a href="https://blog.csdn.net/vhwfr2u02q/article/details/83005905" target="_blank" rel="noopener">https://blog.csdn.net/vhwfr2u02q/article/details/83005905</a>  vue ssr 不可不知的问题<br><a href="https://ke.qq.com/course/package/20989?tuin=37f476dd" target="_blank" rel="noopener">https://ke.qq.com/course/package/20989?tuin=37f476dd</a> 视频回放  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;进入页面loading加载状态，页面白屏时间长&lt;br&gt;原因是客户端渲染：html 仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>手机端使用audio遇到的问题</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E6%89%8B%E6%9C%BA%E7%AB%AF%E4%BD%BF%E7%94%A8audio%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E6%89%8B%E6%9C%BA%E7%AB%AF%E4%BD%BF%E7%94%A8audio%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-30T02:17:33.282Z</published>
    <updated>2020-06-30T02:17:49.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>比较安卓与iOS端audio使用的差异，主要解决ios的兼容性问题  </p><h4 id="数据加载完成时的事件"><a href="#数据加载完成时的事件" class="headerlink" title="数据加载完成时的事件"></a>数据加载完成时的事件</h4><p>两个终端可播放的事件不一样，所以可以在做兼容时区分一下终端  </p><ul><li>安卓<br>loadedmetadata，当浏览器已加载音频/视频的元数据时  </li><li>iOS<br>canplaythrough，当浏览器可在不因缓冲而停顿的情况下进行播放时  </li></ul><h4 id="ios预加载和首次自动播放的问题"><a href="#ios预加载和首次自动播放的问题" class="headerlink" title="ios预加载和首次自动播放的问题"></a>ios预加载和首次自动播放的问题</h4><p>安卓端可以在页面初始化进行资源的加载，并且可以出发播放器的播放事件，不会用问题。但是ios就不一样了。<br>iOS端的媒体资源的加载与首次自动播放必须在微信端weixinJsBridgeReady事件中进行，获取通过用户手动出发的事件中进行，该事件也不可通过我们js模拟。  </p><h4 id="多个媒体资源需要连续播放时不能复用播放器"><a href="#多个媒体资源需要连续播放时不能复用播放器" class="headerlink" title="多个媒体资源需要连续播放时不能复用播放器"></a>多个媒体资源需要连续播放时不能复用播放器</h4><p>比如我们需要连续播放多个语音，就不能只创建一个audio标签，因为每次加载都需动态改变播放链接，然后执行load进行下载，那么这个下载过程可能让用户等很久。并且在iOS端，会有加载两次的bug。<br>解决方案就是为每一条音频都动态创建一个播放标签，动态加载资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;比较安卓与iOS端audio使用的差异，主要解决ios的兼容性问题  &lt;/p&gt;
&lt;h4 id=&quot;数据加载完成时的事件&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue3.0学习</title>
    <link href="https://mrdouhua.github.io/2020/06/30/vue3.0%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mrdouhua.github.io/2020/06/30/vue3.0%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-30T02:16:37.643Z</published>
    <updated>2020-06-30T02:16:55.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>代码仓库中有个 packages 目录，里面主要是 Vue 3 的主要功能实现。  </p><ul><li>reactivity 目录：数据响应式系统，这是一个单独的系统，可以与任何框架配合使用。</li><li>runtime-core 目录：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API，我们可以利用这个 runtime 实现针对某个具体平台的高阶 runtime，比如自定义渲染器。</li><li>runtime-dom 目录: 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等。</li><li>runtime-test 目录: 一个专门为了测试而写的轻量级 runtime。由于这个 rumtime 「渲染」出的 DOM 树其实是一个 JS 对象，所以这个 runtime 可以用在所有 JS 环境里。你可以用它来测试渲染是否正确。它还可以用于序列化 DOM、触发 DOM 事件，以及记录某次更新中的 DOM 操作。</li><li>server-renderer 目录: 用于 SSR，尚未实现。</li><li>compiler-core 目录: 平台无关的编译器，它既包含可扩展的基础功能，也包含所有平台无关的插件。</li><li>compiler-dom 目录: 针对浏览器的编译器。</li><li>shared 目录: 没有暴露任何 API，主要包含了一些平台无关的内部帮助方法。</li><li>vue 目录: 用于构建「完整」版本，引用了上面提到的 runtime 和 compiler目录。  </li></ul><p>关于阅读顺序，我的建议是</p><p>先读 reactivity，能最快了解 Vue 3 的新特性；<br>再读 rumtime，理解组件和生命周期的实现；<br>如果还有时间再读 compiler，理解编译优化过程。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h3&gt;&lt;p&gt;代码仓库中有个 packages 目录，里面主要是 Vue 3 的主要功能实现。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reacti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PhotoShop CC Web切图界面设置</title>
    <link href="https://mrdouhua.github.io/2020/06/30/PhotoShop%20CC%20Web%E5%88%87%E5%9B%BE%E7%95%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE/"/>
    <id>https://mrdouhua.github.io/2020/06/30/PhotoShop%20CC%20Web%E5%88%87%E5%9B%BE%E7%95%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE/</id>
    <published>2020-06-30T02:14:24.241Z</published>
    <updated>2020-06-30T02:14:56.094Z</updated>
    
    <content type="html"><![CDATA[<ul><li>界面为移动工具时（快捷键V），选中左上角的图层。</li><li>点击视图，选中显示→智能参考线，与标尺。</li><li>点击窗口，把“库” “颜色”去掉，把屏幕右上角的“通道” “路径”关闭，旁边的“属性”关闭，选中“图层” “信息” “字符”。把“信息” “字符”，里面的“段落”，“属性”关闭。</li><li>单击信息右边的按钮，选着面板选项，第一颜色选择RGB，下面选上文档大小。</li><li>单击编辑，选择最下面的首选项→单位与标尺，文字→像素</li><li>窗口→工作区→新建工作区，取名Web切图，选择键盘快捷键与菜单，保存。→→这是为了保存刚才的设置。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;界面为移动工具时（快捷键V），选中左上角的图层。&lt;/li&gt;
&lt;li&gt;点击视图，选中显示→智能参考线，与标尺。&lt;/li&gt;
&lt;li&gt;点击窗口，把“库” “颜色”去掉，把屏幕右上角的“通道” “路径”关闭，旁边的“属性”关闭，选中“图层” “信息” “字符”。把“信息
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSS3 过度与动画</title>
    <link href="https://mrdouhua.github.io/2020/06/30/CSS3%20%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>https://mrdouhua.github.io/2020/06/30/CSS3%20%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB/</id>
    <published>2020-06-30T01:56:19.888Z</published>
    <updated>2020-07-07T06:59:31.431Z</updated>
    
    <content type="html"><![CDATA[<p>CSS3的过度模块挺好用的，可以让一个属性在两个状态之间移动的动画。</p><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>transform设置形状</p><ul><li>translate</li><li>scale</li><li>rotate</li><li>skew 倾斜<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2>Transition是一种直观上的效果，让DOM元素的某个属性在固定时间内从一旧值到一新值。</li></ul><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>Internet Explorer 10、Firefox、Chrome 以及 Opera 支持 transition 属性。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">background:red;</span><br><span class="line">transition:width 2s;</span><br><span class="line">-moz-transition:width 2s; &#x2F;* Firefox 4 *&#x2F;</span><br><span class="line">-webkit-transition:width 2s; &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">-o-transition:width 2s; &#x2F;* Opera *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">div:hover</span><br><span class="line">&#123;</span><br><span class="line">width:300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2015490-009b1ea32ce21f77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><strong>transition-timing-function</strong><br>既然是动画，那么就有动画的运行速率，不同的速度会产生不同的结果，以下是可取值。<br>ease：（逐渐变慢）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0).<br>linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0).<br>ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0).<br>ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0).<br>ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)</p><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p>简写的 transition 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: transition-property transition-duration transition-timing-function transition-delay</span><br></pre></td></tr></table></figure><h2 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes &#39;name&#39; &#123;</span><br><span class="line">    keyframe &#123;</span><br><span class="line">    property: value;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>匀速向下移动:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mymove</span><br><span class="line">&#123;</span><br><span class="line">from &#123;top:0px;&#125;</span><br><span class="line">to &#123;top:200px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes mymove &#x2F;* Firefox *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">from &#123;top:0px;&#125;</span><br><span class="line">to &#123;top:200px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes mymove &#x2F;* Safari 和 Chrome *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">from &#123;top:0px;&#125;</span><br><span class="line">to &#123;top:200px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-o-keyframes mymove &#x2F;* Opera *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">from &#123;top:0px;&#125;</span><br><span class="line">to &#123;top:200px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。<br>在一个动画中添加多个 keyframe 选择器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mymove</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">25%  &#123;top:200px;&#125;</span><br><span class="line">50%  &#123;top:100px;&#125;</span><br><span class="line">75%  &#123;top:200px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes mymove &#x2F;* Firefox *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">25%  &#123;top:200px;&#125;</span><br><span class="line">50%  &#123;top:100px;&#125;</span><br><span class="line">75%  &#123;top:200px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes mymove &#x2F;* Safari 和 Chrome *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">25%  &#123;top:200px;&#125;</span><br><span class="line">50%  &#123;top:100px;&#125;</span><br><span class="line">75%  &#123;top:200px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-o-keyframes mymove &#x2F;* Opera *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">25%  &#123;top:200px;&#125;</span><br><span class="line">50%  &#123;top:100px;&#125;</span><br><span class="line">75%  &#123;top:200px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">background:red;</span><br><span class="line">position:relative;</span><br><span class="line">animation:mymove 5s infinite;</span><br><span class="line">-moz-animation:mymove 5s infinite; &#x2F;* Firefox *&#x2F;</span><br><span class="line">-webkit-animation:mymove 5s infinite; &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">-o-animation:mymove 5s infinite; &#x2F;* Opera *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还可以添加这些<strong>动画属性</strong><br><strong>名称：</strong>animation-name</p><p><strong>持续时间：</strong>animation-duration</p><p><strong>计时函数：</strong>animation-timing-function<br>animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out</p><p><strong>延迟：</strong>animation-delay</p><p><strong>迭代次数：</strong>animation-iteration-count<br>animation-iteration-count是用来指定元素播放动画的循环次数，其可以取值<number>为数字，其默认值为“1”；infinite为无限次数循环。</p><p><strong>播放状态：</strong>animation-play-state<br>其主要有两个值，running和paused</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS3的过度模块挺好用的，可以让一个属性在两个状态之间移动的动画。&lt;/p&gt;
&lt;h2 id=&quot;transform&quot;&gt;&lt;a href=&quot;#transform&quot; class=&quot;headerlink&quot; title=&quot;transform&quot;&gt;&lt;/a&gt;transform&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSS3 2D</title>
    <link href="https://mrdouhua.github.io/2020/06/30/CSS3%202D/"/>
    <id>https://mrdouhua.github.io/2020/06/30/CSS3%202D/</id>
    <published>2020-06-30T01:56:19.272Z</published>
    <updated>2020-06-30T02:00:40.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h2><p>CSS3转换，我们可以移动，比例化，反过来，旋转，和拉伸元素。</p><ul><li>translate()</li><li>rotate()</li><li>scale()</li><li>skew()</li><li>matrix()</li></ul><h3 id="translate-方法"><a href="#translate-方法" class="headerlink" title="translate() 方法"></a>translate() 方法</h3><p>translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: translate(50px,100px);</span><br><span class="line">-ms-transform: translate(50px,100px); &#x2F;* IE 9 *&#x2F;</span><br><span class="line">-webkit-transform: translate(50px,100px); &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>translateX(n)    定义 2D 转换，沿着 X 轴移动元素。</li><li>translateY(n)    定义 2D 转换，沿着 Y 轴移动元素。</li></ul><h3 id="rotate-方法"><a href="#rotate-方法" class="headerlink" title="rotate() 方法"></a>rotate() 方法</h3><p>rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: rotate(30deg);</span><br><span class="line">-ms-transform: rotate(30deg); &#x2F;* IE 9 *&#x2F;</span><br><span class="line">-webkit-transform: rotate(30deg); &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scale-方法"><a href="#scale-方法" class="headerlink" title="scale() 方法"></a>scale() 方法</h3><p>scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; scale（2,3）转变宽度为原来的大小的2倍，和其原始大小3倍的高度。</span><br><span class="line">-ms-transform:scale(2,3); &#x2F;* IE 9 *&#x2F;</span><br><span class="line">-webkit-transform: scale(2,3); &#x2F;* Safari *&#x2F;</span><br><span class="line">transform: scale(2,3); &#x2F;* 标准语法 *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="skew-方法"><a href="#skew-方法" class="headerlink" title="skew() 方法"></a>skew() 方法</h3><p>包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。</p><ul><li>skewX(<angle>);表示只在X轴(水平方向)倾斜。</li><li>skewY(<angle>);表示只在Y轴(垂直方向)倾斜。</li></ul><h3 id="matrix-方法"><a href="#matrix-方法" class="headerlink" title="matrix() 方法"></a>matrix() 方法</h3><p>matrix()方法把2D变换方法合并成一个。<br>matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS3-2D转换&quot;&gt;&lt;a href=&quot;#CSS3-2D转换&quot; class=&quot;headerlink&quot; title=&quot;CSS3 2D转换&quot;&gt;&lt;/a&gt;CSS3 2D转换&lt;/h2&gt;&lt;p&gt;CSS3转换，我们可以移动，比例化，反过来，旋转，和拉伸元素。&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Web Workers实现javascript多线程</title>
    <link href="https://mrdouhua.github.io/2020/06/30/Web%20Workers%E5%AE%9E%E7%8E%B0javascript%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://mrdouhua.github.io/2020/06/30/Web%20Workers%E5%AE%9E%E7%8E%B0javascript%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-06-30T01:56:18.641Z</published>
    <updated>2020-06-30T02:00:26.084Z</updated>
    
    <content type="html"><![CDATA[<p>大家可能都知道javascript是单线程。但在HTML5中新增与线程相关的一个API，Web Workers可以实现Web平台上多线程处理的功能。Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。</p><p>我们需要把希望单独执行的javascript代码放到一个单独的js文件中，然后在页面中调用Worker构造函数来创建一个线程，参数是该文件路径，参数存放如果是相对地址，那么要以包含调用Worker构造函数语句所在脚本为参照，如果是绝对路径，需要保证同源（协议+主机+端口）。这个文件不需要我们在页面使用script标签显示引用</p><p>创建一个新的 worker 十分简单。你所要做的就是调用 Worker() 构造函数，指定一个要在 worker 线程内运行的脚本的 URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myWorker &#x3D; new Worker(&quot;my_task.js&quot;);</span><br><span class="line"></span><br><span class="line">myWorker.onmessage &#x3D; function (oEvent) &#123;</span><br><span class="line">  console.log(&quot;Called back by the worker!\n&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者，你也可以使用 addEventListener()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myWorker &#x3D; new Worker(&quot;my_task.js&quot;);</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&quot;message&quot;, function (oEvent) &#123;</span><br><span class="line">  console.log(&quot;Called back by the worker!\n&quot;);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(&quot;&quot;); &#x2F;&#x2F; start the worker.</span><br></pre></td></tr></table></figure><p>worker对象只有两个<strong>属性</strong></p><ul><li>onerror:当worker运行出现错误，并且没有在worker中ing捕获，会在此捕获</li><li>onmessage:当worker向主线程发送消息是调用</li></ul><p>在其prototype内有两个重要<strong>方法</strong></p><ul><li><strong>postMessage</strong>:很熟悉的赶脚，之前我们介绍过window对象的postMessage()方法，woker的postMessage方法和window的比较类似，但参数略有不同，只需要传递消息内容就可以，而且支持所有JavaScript原生数据类型，当然不放心的话同样也可以序列化为字符串传递</li><li><strong>terminate</strong>:终止worker执行，有些worker执行比较慢，主线程可以主动终止其执行</li></ul><p><strong>worker.onmessage</strong><br>在这个句柄内接收外部调用者传递的参数，参数可以通过e.data获取。即获取子线程中postMessage时方法传来的数据。</p><p>在worker中不能使用window对象和docuemnt对象。<br>但可以使用这些：</p><ul><li>JavaScript的全局对象：JSON、Date()、Array</li><li>self自身引用</li><li>location对象，但是其属性都是只读的，改了也影响不到调用者</li><li>navigator对象</li><li>setTimeout()、setInterval()及其对应清除方法</li><li>addEventListener()、removeEventListener()</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家可能都知道javascript是单线程。但在HTML5中新增与线程相关的一个API，Web Workers可以实现Web平台上多线程处理的功能。Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。&lt;/p&gt;
&lt;p&gt;我
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈html5 WebRTC（待跟新）</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E6%B5%85%E8%B0%88html5%20WebRTC%EF%BC%88%E5%BE%85%E8%B7%9F%E6%96%B0%EF%BC%89/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E6%B5%85%E8%B0%88html5%20WebRTC%EF%BC%88%E5%BE%85%E8%B7%9F%E6%96%B0%EF%BC%89/</id>
    <published>2020-06-30T01:56:18.019Z</published>
    <updated>2020-06-30T02:00:10.196Z</updated>
    
    <content type="html"><![CDATA[<p>WebRTC，名称源自网页实时通信（Web Real-Time Communication）的缩写,它主要用来让浏览器实时获取和交换视频、音频和数据。</p><p>在两个浏览器之间为了通信、游戏或文件传输而发送数据是一个非常复杂的过程，因为需要搭建服务器，还可能需要配置数据中心，也很难保证数据的私密性。<br>但这些问题在WebRTc中的RTCDataChannel API中得到减缓，因为可以直接将数据从一个浏览器发送到另外一个浏览器。</p><p>WebRTC共分三个API。</p><ul><li>MediaStream（又称getUserMedia）</li><li>RTCPeerConnection</li><li>RTCDataChannel</li></ul><h2 id="getUserMedia"><a href="#getUserMedia" class="headerlink" title="getUserMedia"></a>getUserMedia</h2><p>getUserMedia方法接受三个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getUserMedia(streams, success, error);</span><br></pre></td></tr></table></figure><ul><li>streams：表示包括哪些多媒体设备的对象</li><li>success：回调函数，获取多媒体设备成功时调用</li><li>error：回调函数，获取多媒体设备失败时调用</li><li><em>例子：*</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.getUserMedia(&#123;</span><br><span class="line">    video: true,</span><br><span class="line">    audio: true</span><br><span class="line">&#125;, onSuccess, onError);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WebRTC，名称源自网页实时通信（Web Real-Time Communication）的缩写,它主要用来让浏览器实时获取和交换视频、音频和数据。&lt;/p&gt;
&lt;p&gt;在两个浏览器之间为了通信、游戏或文件传输而发送数据是一个非常复杂的过程，因为需要搭建服务器，还可能需要配置数
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>html5 通信API(跟新中)</title>
    <link href="https://mrdouhua.github.io/2020/06/30/html5%20%E9%80%9A%E4%BF%A1API(%E8%B7%9F%E6%96%B0%E4%B8%AD)/"/>
    <id>https://mrdouhua.github.io/2020/06/30/html5%20%E9%80%9A%E4%BF%A1API(%E8%B7%9F%E6%96%B0%E4%B8%AD)/</id>
    <published>2020-06-30T01:56:17.352Z</published>
    <updated>2020-06-30T02:00:00.607Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5种新增与通信相关的三个功能</p><ul><li>跨文档消息传输功能<br>可以在不同网页、不同端口、不同域之间进行消息的传递</li><li>使用WebSockets API来通过socket端口传递数据的功能<br>可以让客户端与服务器端通过socket端口来传输数据</li><li>通过Server-Sent Events API将服务器端事件主动推送到客户端的功能<br>服务器端可以每隔一段时间主动向客户端发送一个携带数据的事件</li></ul><h2 id="跨文档消息传输"><a href="#跨文档消息传输" class="headerlink" title="跨文档消息传输"></a>跨文档消息传输</h2><p>HTML5提供了在网页文档之间互相接受与发送信息的功能，只要获取到网页所在窗口对象的实例，同源（域+端口号）的Web网页之间可以互相通信，也可以实现跨域通信。 </p><p><strong>发送</strong><br>使用window对象的postMessage方法向其他窗口发送消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message,targetOrign);</span><br></pre></td></tr></table></figure><p>该方法使用两个参数，第一个参数为所发送的消息文本，但也可以是任何JavaScript对象（通过JSON转换对象为文本）;第二个参数为接收消息的对象窗口的URL地址。</p><p><strong>接受</strong><br>接受从其他窗口那里发过来的消息，需要对窗口对象的message事件进行监视</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;message&quot;,function()&#123;...&#125;,false);</span><br></pre></td></tr></table></figure><h2 id="通道通信"><a href="#通道通信" class="headerlink" title="通道通信"></a>通道通信</h2><p>通道通信提供了一种在多个源之间进行通信的方法，这些源之间通过端口进行通信。<br>目前只有chrome支持通道通信机制。</p><h2 id="WebSockets-通信"><a href="#WebSockets-通信" class="headerlink" title="WebSockets 通信"></a>WebSockets 通信</h2><p>WebSocket API是下一代客户端-服务器的异步通信方法。也是是Html5提供的在Web应用程序中客户端与服务器端之间进行的非HTTP的通信机制。<br>WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。WebSocket并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而WebSocket允许跨域通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML5种新增与通信相关的三个功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨文档消息传输功能&lt;br&gt;可以在不同网页、不同端口、不同域之间进行消息的传递&lt;/li&gt;
&lt;li&gt;使用WebSockets API来通过socket端口传递数据的功能&lt;br&gt;可以让客户端与服务器端通过socket
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>扩展的XMLHttpRequest API</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E6%89%A9%E5%B1%95%E7%9A%84XMLHttpRequest%20API/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E6%89%A9%E5%B1%95%E7%9A%84XMLHttpRequest%20API/</id>
    <published>2020-06-30T01:56:16.721Z</published>
    <updated>2020-06-30T01:59:30.052Z</updated>
    
    <content type="html"><![CDATA[<p>随着HTML5的到来，XMLHttpRequest API中新增了关于跨域请求、进度时间的上传、二进制数据的上传及下载等许多功能。</p><h3 id="从服务器获取二进制数据"><a href="#从服务器获取二进制数据" class="headerlink" title="从服务器获取二进制数据"></a>从服务器获取二进制数据</h3><p>在HTML5之前，从服务器获取二进制数据，需要设置XMLHttpRequest对象的overrideMimeType方法，以此重载数据的Mime Type类型，用户自定义数据的字符编码类型。但这样有个缺点，responseText返回的并不是原始的二进制数据，而是一串字符串。<br>在HTML5中，新增了responseType属性与response属性来解决这个问题。<br><strong>responseType</strong><br>指定服务器返回数据的数据类型，text、arraybuffer、blob、json与document。<br><strong>response</strong><br>如果请求服务器成功，response属性值返回服务器响应的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BlobBuilder&#x3D; window.MozBlobBuilder||</span><br><span class="line"> window.WebKitBlobBuilder||</span><br><span class="line"> window.BlobBuilder;</span><br><span class="line">var xhr &#x3D;newXMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;,&#39;&#x2F;path&#x2F;to&#x2F;image.png&#39;,true);</span><br><span class="line">xhr.responseType &#x3D;&#39;arraybuffer&#39;;</span><br><span class="line">xhr.onload&#x3D;function(e)&#123;</span><br><span class="line">    if(this.status &#x3D;&#x3D;200)&#123;var bb &#x3D;newBlobBuilder();</span><br><span class="line">    bb.append(this.response);&#x2F;&#x2F; Note: not xhr.responseTextvar blob &#x3D; bb.getBlob(&#39;image&#x2F;png&#39;);...</span><br><span class="line">&#125;&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p>ArrayBuffer 是二进制数据通用的固定长度容器。当responseType属性值为ArrayBuffer时，服务器端将会返回一个ArrayBuffer对象。</p><h3 id="Blob-响应"><a href="#Blob-响应" class="headerlink" title="Blob 响应"></a>Blob 响应</h3><p>当不需要修改从服务器端下载的二进制数据时，除了设置为ArrayBuffer外，还可以将responseType属性值为blob。</p><h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>HTML5之前，大多数浏览器只能通过send方法字符串或Document对象。<br>在HTML5中，可接受以下任何类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMString、Document、FormData、Blob、File、ArrayBuffer</span><br></pre></td></tr></table></figure><h3 id="发送字符串数据：xhr-send-DOMString"><a href="#发送字符串数据：xhr-send-DOMString" class="headerlink" title="发送字符串数据：xhr.send(DOMString)"></a>发送字符串数据：xhr.send(DOMString)</h3><p>设置 responseType=’text’</p><h3 id="发送表单数据：xhr-send-FormData"><a href="#发送表单数据：xhr-send-FormData" class="headerlink" title="发送表单数据：xhr.send(FormData)"></a>发送表单数据：xhr.send(FormData)</h3><p>html表单enctype属性设置multipart/form-data，input设置name属性。然后js里构建FormData对象。<br><strong>js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var formData&#x3D;new FormData(myform);</span><br><span class="line">formData.append(&#39;username&#39;,&#39;johndoe&#39;);</span><br><span class="line">formData.append(&#39;id&#39;,123456);</span><br><span class="line">var xhr &#x3D;newXMLHttpRequest();</span><br><span class="line">  xhr.open(&#39;POST&#39;,&#39;&#x2F;server&#39;,true);</span><br><span class="line">  xhr.onload &#x3D;function(e)&#123;...&#125;;</span><br><span class="line">  xhr.send(formData);</span><br></pre></td></tr></table></figure><p><strong>html</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id&#x3D;&quot;myform&quot; name&#x3D;&quot;myform&quot; action&#x3D;&quot;&#x2F;server&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;johndoe&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;number&quot; name&#x3D;&quot;id&quot; value&#x3D;&quot;123456&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; onclick&#x3D;&quot;return sendForm(this.form);&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>上传文件也是通过构建FormData对象，上传方法与上述相似。</p><h3 id="上传Blob对象"><a href="#上传Blob对象" class="headerlink" title="上传Blob对象"></a>上传Blob对象</h3><p>所有File对象都是一个Blob对象，因此可以通过发送Blob对象的方法来上传文件。<br>当需要显示上传进度时，通过Blob对象也十分适合。<br>但目前只有Chrome浏览器支持上传数据（不限于Blob对象）的同时同步跟新进度条控件中所显示的进度。</p><h3 id="跨域数据请求"><a href="#跨域数据请求" class="headerlink" title="跨域数据请求"></a>跨域数据请求</h3><p>在HTML5以前，通过ajax不能跨域，在HTML5中，由于支持跨域数据通信，所以可以实现跨域数据请求。<br>跨域需要服务器启用CORS，如果服务器端已启用了 CORS，那么提交跨域请求就和普通的 XMLHttpRequest 请求没什么区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着HTML5的到来，XMLHttpRequest API中新增了关于跨域请求、进度时间的上传、二进制数据的上传及下载等许多功能。&lt;/p&gt;
&lt;h3 id=&quot;从服务器获取二进制数据&quot;&gt;&lt;a href=&quot;#从服务器获取二进制数据&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>call、apply、bind区别与用法</title>
    <link href="https://mrdouhua.github.io/2020/06/30/call%E3%80%81apply%E3%80%81bind%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E6%B3%95/"/>
    <id>https://mrdouhua.github.io/2020/06/30/call%E3%80%81apply%E3%80%81bind%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E6%B3%95/</id>
    <published>2020-06-30T01:56:16.071Z</published>
    <updated>2020-06-30T01:59:22.716Z</updated>
    
    <content type="html"><![CDATA[<p>call与apply方法都是改变函数体内的this指向，即改变函数运行时的上下文。若没有什么对象调用这个方法，所以第一个参数可以写作null或者本身；</p><p>在call与apply方法中，第一个参数就是this的指向，但apply第二个参数是一个数组，call第二个及以后直接是数组中里面的元素。</p><p><strong>call与apply常用法</strong></p><ul><li>数组之间的追加</li><li>获取数组中的最大值和最小值，利用Math的min和max方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4];</span><br><span class="line">Math.max.apply(null, arr) &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure></li><li>验证是否是数组（前提是toString（）方法没有被重写过）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function   isArray(obj)&#123; </span><br><span class="line">    return Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39; ; &#x2F;&#x2F; true or false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>bind()也是改变函数体内this的指向，bind会创建一个新函数，该函数不会立即执行，需要自己手动调用执行。</p><p>三个的使用<strong>区别</strong></p><ul><li>都是用来改变函数的this对象的指向的</li><li>第一个参数都是this要指向的对象</li><li>都可以利用后续参数传参</li><li>bind是返回对应函数，便于稍后调用，apply、call是立即调用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call与apply方法都是改变函数体内的this指向，即改变函数运行时的上下文。若没有什么对象调用这个方法，所以第一个参数可以写作null或者本身；&lt;/p&gt;
&lt;p&gt;在call与apply方法中，第一个参数就是this的指向，但apply第二个参数是一个数组，call第二个
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>html5离线web应用程序</title>
    <link href="https://mrdouhua.github.io/2020/06/30/html5%E7%A6%BB%E7%BA%BFweb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    <id>https://mrdouhua.github.io/2020/06/30/html5%E7%A6%BB%E7%BA%BFweb%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-06-30T01:56:15.465Z</published>
    <updated>2020-06-30T01:59:15.349Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5提供了本地缓存使用的API，使得我们可以开发离线应用。传统的Web应用程序一般是利用网页缓存，网页缓存有缺点也有优点。下面是本地缓存和网页缓存的对比：</p><ul><li>如果用户没有连接网络，就不能使用Web应用程序，相比离线浏览 - 用户可在应用离线时使用它们</li><li>网页缓存不可靠，不安全，本地缓存安全可靠，可以指定具体缓存的内容</li><li>本地缓存为整个Web应用，网页缓存为单个网页</li><li>速度 - 已缓存资源加载得更快</li><li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li></ul><p>为了让整个Web应用离线也能工作，就需要把HTML，CSS，JS等进行本地缓存。</p><h3 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h3><p>Web应用程序的本地缓存是通过每个页面的manifest文件来管理的。manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。</p><p>###manifest 文件组成部分（三个）</p><ul><li>CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存</li><li>NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存，可以为通配符，表示没有在manifest文件中指定的都不会进行本地缓存</li><li>FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul><h3 id="缓存更新"><a href="#缓存更新" class="headerlink" title="缓存更新"></a>缓存更新</h3><p>缓存一般会保持原有状态，直至：</p><ul><li>用户清空浏览器缓存</li><li>manifest 文件被修改（参阅下面的提示）</li><li>由程序来更新应用缓存</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 2012-02-21 v1.0.0</span><br><span class="line">&#x2F;theme.css</span><br><span class="line">&#x2F;logo.gif</span><br><span class="line">&#x2F;main.js</span><br><span class="line"></span><br><span class="line">NETWORK:</span><br><span class="line">login.asp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">&#x2F;html5&#x2F; &#x2F;404.html</span><br></pre></td></tr></table></figure><h2 id="浏览器与服务器的交互过程"><a href="#浏览器与服务器的交互过程" class="headerlink" title="浏览器与服务器的交互过程"></a>浏览器与服务器的交互过程</h2><p>首次访问网站时的交互过程如下：</p><blockquote></blockquote><ol><li>浏览器请求访问网站，即发送url；</li><li>服务器返回请求网页，例如：index.html；</li><li>浏览器解析网页，请求页面上所有资源文件，包括HTML文件、图像文件、CSS文件、JS文件以及manifest文件；</li><li>服务器返回所有资源文件；</li><li>浏览器处理manifest文件，请求manifest中所有要求本地缓存的文件，包括index.html页面本身，即使刚才已经请求过这些文件。如果你要求本地缓存所有文件，这将是一个比较大的重复的请求过程；</li><li>服务器返回所有要求本地缓存的文件；</li><li>浏览器对本地缓存进行更新，存入包括页面本身在内的所有要求本地缓存的资源文件，并且触发一个事件，通知本地缓存被更新。</li></ol><p>　<br>本地缓存更新完毕，再次打开浏览器访问该网站，而且manifest文件没有被修改过，它们的交互过程如下：</p><blockquote></blockquote><ol><li>浏览器再次请求访问网站；</li><li>浏览器发现这个页面被本地缓存，于是使用本地缓存中index.html页面；</li><li>浏览器解析index.html页面，使用所有本地缓存中的资源文件；</li><li>浏览器向服务器请求manifest文件；</li><li>服务器返回一个304代码，通知浏览器manifest没有发生变化。</li></ol><p>只要页面上的资源文件被本地缓存过，下次浏览器打开这个页面时，总是先使用本地缓存中的资源，然后请求manifest文件。</p><p>　<br>如果再次打开浏览器时，manifest文件已经被更新过了，那么浏览器与服务器之间的交互过程如下：</p><blockquote></blockquote><ol><li>浏览器再次请求访问网站；</li><li>浏览器发现这个页面被本地缓存，于是使用本地缓存中的index.html页面；</li><li>浏览器解析index.html页面，使用所有本地缓存中的资源文件；</li><li>浏览器向服务器请求manifest文件；</li><li>服务器返回更新过年manifest文件；</li><li>浏览器处理manifest文件，发现该文件已被更新，于是请求所有要求进行本地缓存的资源文件，包括index.html页面本身；</li><li>服务器返回要求进行本地缓存的资源文件；</li><li>浏览器对本地缓存进行更新，丰入所有新的资源文件。并且触发一个事件，通知本地缓存被更新。</li></ol><p>注意，即使资源文件被修改过了，在上面的第三步中已经装入的资源文件是不会发生变化的，例如图片不会突然变成新的图片，脚本文件也不会突然使用新的脚本文件，</p><p>　</p><h2 id="applicationCache对象"><a href="#applicationCache对象" class="headerlink" title="applicationCache对象"></a>applicationCache对象</h2><p>applicationCache对象代表本地缓存，可以用它来通知用户本地缓存中已经被更新，也允许用户手工更新本地缓存。</p><h3 id="updateready事件"><a href="#updateready事件" class="headerlink" title="updateready事件"></a>updateready事件</h3><p>manefest跟新会触发applicationCache对象的<strong>updateready事件</strong>，通知本地缓存已经被更新。可以利用该事件告诉用户本地缓存已经被更新，用户需要手工刷新页面来得到最新版本的应用程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">applicationCache.addEventListener(&quot;updateready&quot;, function(event) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 本地缓存已被更新，通知用户。  </span><br><span class="line">alert(&quot;本地缓存已被更新，可以刷新页面来得到本程序的最新版本。&quot;);  </span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure><h3 id="swapCache"><a href="#swapCache" class="headerlink" title="swapCache()"></a>swapCache()</h3><p>applicationCache对象的swapCache()方法来控制如何进行本地缓存的更新及更新的时机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> applicationCache.addEventListener(&quot;updateready&quot;, function(event) &#123;  </span><br><span class="line"> &#x2F;&#x2F; 本地缓存已被更新，通知用户。  </span><br><span class="line">alert(&quot;正在更新本地缓存……&quot;);  </span><br><span class="line"> applicationCache.swapCache();  </span><br><span class="line"> alert(&quot;本地缓存更新完毕，可以刷新页面使用最新版应用程序。&quot;);  </span><br><span class="line"> &#125;, false);</span><br></pre></td></tr></table></figure><p>比较updateready事件与swapCache()方法：</p><ul><li>updateready表示资源从服务器上请求过来了，自动跟新</li><li>swapCache()表示updateready事件发生后，用户自己跟新</li><li>如果不使用swapCache()方法，本地缓存一样会被更新，但是，更新的时候不一样。如果不调用该方法，本地缓存将在下一次打开本页面时被更新；如果调用该方法，则本地缓存将会被立刻更新。</li><li>尽管使用swapCache()方法立刻更新了本地缓存，但是并不意味着我们页面上的图像和脚本文件也会被立刻更新，它们都是在重新打开本页面时才会生效</li></ul><h2 id="applicationCache对象的事件"><a href="#applicationCache对象的事件" class="headerlink" title="applicationCache对象的事件"></a>applicationCache对象的事件</h2><p>applicationCache对象的事件除了具有update方法与swapCache()方法，还具有其他一系列事件。　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML5提供了本地缓存使用的API，使得我们可以开发离线应用。传统的Web应用程序一般是利用网页缓存，网页缓存有缺点也有优点。下面是本地缓存和网页缓存的对比：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果用户没有连接网络，就不能使用Web应用程序，相比离线浏览 - 用户可在应用离线时使
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Web Storage</title>
    <link href="https://mrdouhua.github.io/2020/06/30/Web%20Storage/"/>
    <id>https://mrdouhua.github.io/2020/06/30/Web%20Storage/</id>
    <published>2020-06-30T01:56:14.830Z</published>
    <updated>2020-06-30T01:59:02.716Z</updated>
    
    <content type="html"><![CDATA[<p>Web Storage是HTML5引入的一个非常重要的功能，可以在客户端本地存储数据，类似HTML4的cookie，但可实现功能要比cookie强大的多，Web Storage官方建议为每个网站5MB。<br><strong>cookie缺点</strong></p><ul><li>每个域名下cookie的大小限制在4KB。</li><li>cookie会包含在每个http请求中，这样会导致发送重复的数据。</li><li>cookie在网络传输过程中没有加密，存在安全隐患。</li></ul><p>Web Storage又分为两种：</p><ul><li>sessionStorage</li><li>localStorage</li></ul><p><strong>SessionStorage：</strong>与session类似，Session Storage保存的数据生存期限与Session期限相同，用户Session结束时，Session Storage保存的数据也就消失了。<br><strong>LocalStorage：</strong> Local Storage保存的数据一直在本地，除非用户或程序显式地清楚，否则这些数据会一致存在。</p><p><strong>常用方法：</strong><br>二者方法一样，但key和value都必须为字符串，换言之，web Storage的API只能操作字符串。</p><ul><li>保存数据：localStorage.setItem(key,value);</li><li>读取数据：localStorage.getItem(key);</li><li>删除单个数据：localStorage.removeItem(key);</li><li>删除所有数据：localStorage.clear();</li><li>得到某个索引的key：localStorage.key(index);</li></ul><p>下面是写的三个小例子<br>1，简单读取数据</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Web Storager&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Web Storager 事例&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;input&quot; name&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;保存数据&quot; onclick&#x3D;&quot;saveStorage(&#39;input&#39;)&quot; name&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;读取数据&quot; onclick&#x3D;&quot;loadStorage(&#39;msg&#39;)&quot; name&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; script.js</span><br><span class="line">&#x2F;&#x2F; localStorage事例</span><br><span class="line">function saveStorage(id)&#123;</span><br><span class="line">var target &#x3D; document.getElementById(id).value;</span><br><span class="line">var str &#x3D; target;</span><br><span class="line">localStorage.setItem(&quot;message&quot;,str);</span><br><span class="line">&#x2F;&#x2F; localStorage.message &#x3D; str;</span><br><span class="line">&#125;</span><br><span class="line">function loadStorage(id)&#123;</span><br><span class="line">var target &#x3D; document.getElementById(id);</span><br><span class="line">var msg &#x3D; localStorage.getItem(&quot;message&quot;);</span><br><span class="line">&#x2F;&#x2F; var msg &#x3D; localStorage.message;</span><br><span class="line">target.innerHTML &#x3D; msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图<br><img src="http://upload-images.jianshu.io/upload_images/2015490-ded421dcb88f4d0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>　<br>2,简单留言板</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;简单的留言板&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;简单的web留言板&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;textarea id&#x3D;&quot;memo&quot; cols&#x3D;&quot;60&quot; rows&#x3D;&quot;10&quot;&gt;&lt;&#x2F;textarea&gt;&lt;br&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;追加&quot; onclick&#x3D;&quot;saveStorage(&#39;memo&#39;);&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;初始化&quot; onclick&#x3D;&quot;clearStorage(&#39;msg&#39;);&quot;&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function saveStorage(id)&#123;</span><br><span class="line">var data &#x3D; document.getElementById(id).value;</span><br><span class="line">var time &#x3D; new Date().getTime();</span><br><span class="line">localStorage.setItem(time,data);</span><br><span class="line">alert(&quot;数据已经保存!&quot;);</span><br><span class="line">loadStorage(&#39;msg&#39;);</span><br><span class="line">&#125;</span><br><span class="line">function loadStorage(id)&#123;</span><br><span class="line">var result &#x3D; &#39;&lt;table border &#x3D; &quot;1&quot;&gt;&#39;;</span><br><span class="line">for(var i &#x3D; 0;i &lt; localStorage.length;i++)&#123;</span><br><span class="line">var key &#x3D; localStorage.key(i);</span><br><span class="line">var value &#x3D; localStorage.getItem(key);</span><br><span class="line">var date &#x3D; new Date();</span><br><span class="line">date.setTime(key);</span><br><span class="line">var datestr &#x3D; date.toGMTString();</span><br><span class="line">result +&#x3D; &#39;&lt;tr&gt;&lt;td&gt;&#39; + value + &#39;&lt;&#x2F;td&gt;&lt;td&gt;&#39; + datestr + &#39;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&#39;;</span><br><span class="line">&#125;</span><br><span class="line">result +&#x3D; &#39;&lt;&#x2F;table&gt;&#39;;</span><br><span class="line">var target &#x3D; document.getElementById(id);</span><br><span class="line">target.innerHTML &#x3D; result;</span><br><span class="line">&#125;</span><br><span class="line">function clearStorage()&#123;</span><br><span class="line">localStorage.clear();</span><br><span class="line">alert(&quot;全部数据被清除!&quot;);</span><br><span class="line">loadStorage(&#39;msg&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图<br><img src="http://upload-images.jianshu.io/upload_images/2015490-cf2e0185f2f2edc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>　<br>3,简易数据库</p><blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;简易数据库示例&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;使用web Storage来做简易的数据库示例&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;姓名：&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;EMAIL：&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;email&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;电话号码：&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;tel&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;备注：&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;memo&quot;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">&lt;td&gt;&lt;&#x2F;td&gt;</span><br><span class="line">&lt;td&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;保存&quot; onclick&#x3D;&quot;saveStorage();&quot;&gt;</span><br><span class="line">&lt;&#x2F;td&gt;</span><br><span class="line">&lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">&lt;hr&gt;</span><br><span class="line">&lt;p&gt;</span><br><span class="line">检索：&lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;find&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;button&quot; value&#x3D;&quot;检索&quot; onclick&#x3D;&quot;findStorage(&#39;msg&#39;)&quot; name&#x3D;&quot;&quot;&gt;</span><br><span class="line">&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;js&#x2F;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function saveStorage()&#123;</span><br><span class="line">var data &#x3D; new Object;</span><br><span class="line">data.name &#x3D; document.getElementById(&#39;name&#39;).value;</span><br><span class="line">data.email &#x3D; document.getElementById(&#39;email&#39;).value;</span><br><span class="line">data.tel &#x3D; document.getElementById(&#39;tel&#39;).value;</span><br><span class="line">data.memo &#x3D; document.getElementById(&#39;memo&#39;).value;</span><br><span class="line">var str &#x3D; JSON.stringify(data);</span><br><span class="line">localStorage.setItem(data.name,str);</span><br><span class="line">alert(&quot;数据已经保存!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">function findStorage(id)&#123;</span><br><span class="line">var find &#x3D; document.getElementById(&#39;find&#39;).value;</span><br><span class="line">var str &#x3D; localStorage.getItem(find);</span><br><span class="line">var data &#x3D; JSON.parse(str);</span><br><span class="line">var result &#x3D; &quot;姓名：&quot; + data.name + &#39;&lt;br&gt;&#39;;</span><br><span class="line">result +&#x3D; &quot;EMAIL：&quot; + data.email + &#39;&lt;br&gt;&#39;;</span><br><span class="line">result +&#x3D; &quot;电话号码：&quot; + data.tel + &#39;&lt;br&gt;&#39;;</span><br><span class="line">result +&#x3D; &quot;备注：&quot; + data.memo + &#39;&lt;br&gt;&#39;;</span><br><span class="line">var target &#x3D; document.getElementById(id);</span><br><span class="line">target.innerHTML &#x3D; result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图<br><img src="http://upload-images.jianshu.io/upload_images/2015490-a6bd4b16334486f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p><p>　</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web Storage是HTML5引入的一个非常重要的功能，可以在客户端本地存储数据，类似HTML4的cookie，但可实现功能要比cookie强大的多，Web Storage官方建议为每个网站5MB。&lt;br&gt;&lt;strong&gt;cookie缺点&lt;/strong&gt;&lt;/p&gt;
&lt;u
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>html5 history api</title>
    <link href="https://mrdouhua.github.io/2020/06/30/html5%20history%20api/"/>
    <id>https://mrdouhua.github.io/2020/06/30/html5%20history%20api/</id>
    <published>2020-06-30T01:56:14.231Z</published>
    <updated>2020-06-30T01:58:56.077Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定义</strong><br>是一种切换浏览器显示页面url的api</p><p><strong>作用</strong><br>该api可以通过脚本语言来管理浏览器的历史记录，<strong>不刷新</strong>页面的情况下动态、显示改变浏览器url，动态修改页面上所显示资源。</p><h3 id="HTML4中的History-API"><a href="#HTML4中的History-API" class="headerlink" title="HTML4中的History API"></a>HTML4中的History API</h3><p>首先讲一下HTML4中的History API中的属性与方法。<br><strong>属性：</strong>length 历史的项数。javascript 所能管到的历史被限制在用浏览器的“前进”“后退”键可以去到的范围。本属性返回的是“前进”和“后退”两个按键之下包含的地址数的和。<br><strong>方法：</strong></p><ul><li>back() 后退，跟按下“后退”键是等效的。</li><li>forward() 前进，跟按下“前进”键是等效的。</li><li>go()，跳转</li></ul><h3 id="pushState-方法"><a href="#pushState-方法" class="headerlink" title="pushState 方法"></a>pushState 方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(null, null, &quot;?id&#x3D;1&quot;);</span><br></pre></td></tr></table></figure><p>接收三个参数，按顺序分别为：</p><ul><li>一个对象或者字符串，用于描述新记录的一些特性。这个参数会被一并添加到历史记录中，以供以后使用。这个参数是开发者根据自己的需要自由给出的。</li><li>一个字符串，代表新页面的标题。当前基本上所有浏览器都会忽略这个参数。</li><li>一个字符串，代表新页面的相对地址，可以接受hash值。</li></ul><h3 id="popstate-事件"><a href="#popstate-事件" class="headerlink" title="popstate 事件"></a>popstate 事件</h3><p>当用户点击浏览器的「前进」、「后退」按钮时，就会触发popstate事件。你可以监听这一事件，从而作出反应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;popstate&quot;, function(e) &#123;</span><br><span class="line">    var state &#x3D; e.state;</span><br><span class="line">    &#x2F;&#x2F; do something...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="replaceState-方法"><a href="#replaceState-方法" class="headerlink" title="replaceState 方法"></a>replaceState 方法</h3><p>不添加一个新记录，而是替换当前的记录（比如对网站的 landing page），则可以使用replaceState方法。这个方法和pushState的参数完全一样。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>history api与ajax经常一起使用，动态改变url，无刷新改变页面内容。<br><strong>ajax不足</strong></p><ul><li>无法使用浏览器的前进、后退来切换前后数据。</li><li>单纯地使用AJAX不利于搜索引擎优化。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;br&gt;是一种切换浏览器显示页面url的api&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;&lt;br&gt;该api可以通过脚本语言来管理浏览器的历史记录，&lt;strong&gt;不刷新&lt;/strong&gt;页面的情况下动态、显示改变浏览器url，
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>弹性布局displaybox与flex区别</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80displaybox%E4%B8%8Eflex%E5%8C%BA%E5%88%AB/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80displaybox%E4%B8%8Eflex%E5%8C%BA%E5%88%AB/</id>
    <published>2020-06-30T01:56:13.722Z</published>
    <updated>2020-06-30T01:58:42.110Z</updated>
    
    <content type="html"><![CDATA[<ul><li>弹性布局是针对Css3的一种新型布局，以一种高效的方式对容器里面的条目布局，对齐，分配空间。而且在位置宽度，高度，或者动态的页面任然可以布局。</li></ul><ul><li>display: box;与display:flex;<ul><li><strong>前者</strong>display:box是2009年的语法版本，使用时需要加上浏览器的前缀，不过现在已经过时了。</li><li><strong>后者</strong>display:flex是2012年最新修正的语法版本，浏览器支持较好，也将成为以后标准的语法。</li><li>中间2011年也提出了一个奇葩的语法版本display:flexbox<br>，非官方的，当时主要是为IE浏览器使用。</li><li>前者是09年之前的规定的写法，后者是12年并且是现在的规范。</li><li>前者是早期浏览器前期支持的写法，后者是现代浏览器支持的写法。</li><li>display: -webkit-box; /* Chrome 4+, Safari 3.1, iOS Safari 3.2+ <em>/ display: -moz-box; /</em> Firefox 17- <em>/<br>display: -webkit-flex; /</em> Chrome 21+, Safari 6.1+, iOS Safari 7+, Opera 15/16 <em>/<br>display: -moz-flex; /</em> Firefox 18+ <em>/<br>display: -ms-flexbox; /</em> IE 10 <em>/<br>display: flex; /</em> Chrome 29+, Firefox 22+, IE 11+, Opera 12.1/17/18, Android 4.4+ */</li></ul></li><li>参考网址 <a href="http://www.zhangxinxu.com/wordpress/?p=1338" target="_blank" rel="noopener">http://www.zhangxinxu.com/wordpress/?p=1338</a> <a href="https://segmentfault.com/q/1010000003497333" target="_blank" rel="noopener">https://segmentfault.com/q/1010000003497333</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;弹性布局是针对Css3的一种新型布局，以一种高效的方式对容器里面的条目布局，对齐，分配空间。而且在位置宽度，高度，或者动态的页面任然可以布局。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;display: box;与display:flex;&lt;ul&gt;
&lt;li&gt;&lt;st
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTTP 缓存</title>
    <link href="https://mrdouhua.github.io/2020/06/30/HTTP%20%E7%BC%93%E5%AD%98/"/>
    <id>https://mrdouhua.github.io/2020/06/30/HTTP%20%E7%BC%93%E5%AD%98/</id>
    <published>2020-06-30T01:56:13.073Z</published>
    <updated>2020-06-30T02:00:59.948Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存优点"><a href="#缓存优点" class="headerlink" title="缓存优点"></a>缓存优点</h2><ul><li>减少了冗余的数据传输</li><li>缓解了网络瓶颈的问题</li><li>降低了对原始服务器的请求，降低了服务器的压力</li><li>降低了距离时延</li></ul><p>缓存分为服务端侧（server side，比如 Nginx、Apache）和客户端侧（client side，比如 web browser）。</p><p>服务端缓存又分为<strong>代理服务器缓存</strong> 和 <strong>反向代理服务器缓存</strong>（也叫网关缓存，比如 Nginx反向代理）<br>客户端侧缓存一般指的是浏览器缓存，目的就是加速各种静态资源的访问，<br>增加用户体验、减轻服务器压力和网络带宽的压力。</p><h2 id="浏览器缓存机制详解"><a href="#浏览器缓存机制详解" class="headerlink" title="浏览器缓存机制详解"></a>浏览器缓存机制详解</h2><p>浏览器缓存控制机制有两种：HTML Meta标签 vs. HTTP头信息</p><h3 id="HTML-Meta标签"><a href="#HTML-Meta标签" class="headerlink" title="HTML Meta标签"></a>HTML Meta标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;META HTTP-EQUIV&#x3D;&quot;Pragma&quot; CONTENT&#x3D;&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure><p>但只有部分浏览器可以支持，而且所有缓存代理服务器都不支持，因为代理不解析HTML内容本身。</p><h3 id="HTTP头信息控制缓存"><a href="#HTTP头信息控制缓存" class="headerlink" title="HTTP头信息控制缓存"></a>HTTP头信息控制缓存</h3><ul><li>浏览器第一次请求流程图<br><img src="http://upload-images.jianshu.io/upload_images/2015490-5a77f9b694dadcb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器第一次请求"></li><li>浏览器再次请求时<br><img src="http://upload-images.jianshu.io/upload_images/2015490-304ee2282a9d3d58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="浏览器再次请求"></li></ul><p>原始服务器的内容可能会发生变化，缓存要经常对其进行检测，看看它们保存的副本是否任是服务器最新版本。<br>缓存对缓存的副本进行在验证时，会向原始服务器发送一个晓得在验证请求。如果内容没有变化，返回 304 Not Modifield状态码。</p><h3 id="如何判断缓存新鲜度"><a href="#如何判断缓存新鲜度" class="headerlink" title="如何判断缓存新鲜度"></a>如何判断缓存新鲜度</h3><p>8 第一种， 浏览器把缓存文件的最后修改时间通过 header ”If-Modified-Since“来告诉Web服务器。·<br>8 第二种， 浏览器把缓存文件的ETag, 通过header “If-None-Match”, 来告诉Web服务器。</p><h3 id="通过最后修改时间-来判断缓存新鲜度"><a href="#通过最后修改时间-来判断缓存新鲜度" class="headerlink" title="通过最后修改时间, 来判断缓存新鲜度"></a>通过最后修改时间, 来判断缓存新鲜度</h3><p>1，浏览器客户端想请求一个文档，  首先检查本地缓存，发现存在这个文档的缓存，  获取缓存中文档的最后修改时间，通过： If-Modified-Since， 发送Request给Web服务器。·<br>2， Web服务器收到Request，将服务器的文档修改时间（Last-Modified）: 跟request header 中的，If-Modified-Since相比较， 如果时间是一样的， 说明缓存还是最新的， Web服务器将发送304 Not Modified给浏览器客户端， 告诉客户端直接使用缓存里的版本</p><p><strong>Expires策略</strong>：Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。<br>Expires 的一个<strong>缺点：</strong>返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大（比如时钟不同步，或者跨时区），那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。</p><p><strong>Cache-control策略</strong>（<em>重点关注</em>）：Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其<strong>优先级</strong>高于Expires。</p><p><strong>缺点：</strong></p><ol><li>某些服务器不能精确得到文件的最后修改时间， 这样就无法通过最后修改时间来判断文件是否更新了。·</li><li>某些文件的修改非常频繁，在秒以下的时间内进行修改. Last-Modified只能精确到秒。</li><li>一些文件的最后修改时间改变了，但是内容并未改变。 我们不希望客户端认为这个文件修改了。</li></ol><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>ETag是实体标签（Entity Tag）的缩写， 根据实体内容生成的一段hash字符串（类似于MD5或者SHA1之后的结果），可以标识资源的状态。 当资源发送改变时，ETag也随之发生变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存优点&quot;&gt;&lt;a href=&quot;#缓存优点&quot; class=&quot;headerlink&quot; title=&quot;缓存优点&quot;&gt;&lt;/a&gt;缓存优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;减少了冗余的数据传输&lt;/li&gt;
&lt;li&gt;缓解了网络瓶颈的问题&lt;/li&gt;
&lt;li&gt;降低了对原始服务器的请求，降低了
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
