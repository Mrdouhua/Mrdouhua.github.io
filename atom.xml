<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>莫克力学习博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://mrdouhua.github.io/"/>
  <updated>2021-03-10T10:55:57.681Z</updated>
  <id>https://mrdouhua.github.io/</id>
  
  <author>
    <name>莫克力</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最简单的微前端方案学习（网易云async-routers）</title>
    <link href="https://mrdouhua.github.io/2021/03/10/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%BD%91%E6%98%93%E4%BA%91async-routers%EF%BC%89/"/>
    <id>https://mrdouhua.github.io/2021/03/10/%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%BE%AE%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%BD%91%E6%98%93%E4%BA%91async-routers%EF%BC%89/</id>
    <published>2021-03-10T10:55:20.000Z</published>
    <updated>2021-03-10T10:55:57.681Z</updated>
    
    <content type="html"><![CDATA[<p>微前端也火了很久了，业界的技术方案也有很多种。这玩意吧，确实也是好东西，它能解决什么问题呢？</p><p>本次摘要</p><p>微前端是什么<br>为什么需要微前端<br>对比几种微前端方案<br>简述网易云方案<br>总结<br>常见问题<br>微前端是什么<br>微前端是一种web 应用技术方案，可以独立编译、发布、开发，可以拥有不同技术栈</p><p>传统项目问题<br>对于大型前端项目，比如公司内部管理系统（CRM系统），如果将所有业务放在一个前端项目里，随着业务功能不断增加，就会导致如下这些问题：</p><p>代码规模庞大，导致编译时间过长，开发、打包速度越来越慢<br>项目文件越来越多，导致查找相关文件变得越来越困难<br>某一个业务的小改动，导致整个项目的打包和部署<br>不能支持多个技术栈，也不利于多个团队共同维护开发</p><p>为什么需要微前端<br>互不影响，升级简单。</p><p>可以很方便的复用已有的功能模块，避免重复开发。</p><p>几种常见的微前端方法<br>qiankun<br>蚂蚁金融研发，基于 single-spa，有基座</p><p>EMP<br>YY PC端的技术方案，基于webpack5 Module Federation，俗称联邦模块，无基座</p><p>网易云<br>方案很简单，有基座，子项目共享基座的vue实例，router与vuex也抽离到基座管理，vue router vuex实例都在基座，各个子项目得main.js是连接基座与子项目得桥梁</p><p>qiankun<br>qiankun基座代码架构很庞大，也无法完全做到状态隔离，使用方式通过使用乾坤的方法注册子应用，项目迁移时改动较小</p><p>特点：庞大，无法完全应用隔离，改动小</p><p>EMP<br>使用的webpack5新特性联邦模块，无基座，是一个典型的去中心应用，需要在每一个子项目写一个配置文件</p><p>特点：联邦模块，去中心应用</p><p>网易云方案的总结</p><p>主项目：用于管理子项目的路由切换、注册子项目的路由和全局 Store 层、提供全局库和方法<br>子项目：用于开发子业务线业务代码，一个子项目对应一个子业务线<br>主项目的 html 要访问子项目里的编译后的 js / css 等资源，需要进行代理转发<br>主项目 router.js 文件中定义了在 vue-router 的 beforeEach 钩子去拦截路由，<br>并根据即将跳转的路由分析出需要哪个子项目，然后去异步加载对应子项目入口文件</p><p>子项目的入口文件 main.js 仅需要将子项目的 routes 与 Store暴露给主项目</p><p>基座有批​量启动命令的功能</p><p>常见问题<br>1）微前端与NPM对比</p><p>2）微前端与多页面片对比</p><p>3）子项目的页面权限校验必须在主项目中进行</p><p>4）主项目的 html 如何访问子项目里的编译后的 js / css 等资源</p><p>5）如果子项目代码更新后，除了打包部署子项目之外，还需要打包部署主项目吗？</p><p>6）子项目入口文件 main.js 不使用 chunkhash 的话，如何防止该文件始终被缓存呢？</p><p>7）公共组件如何复用</p><p>8）如何合并各个项目</p><p>一，对比NPM</p><p>更新npm包版本<br>更新A管理系统应用的npm包版本<br>发布部署A管理系统应用<br>对B和C管理系统应用循环2和3步骤</p><p>微前端一个闪亮点，就是可以做到一键更新。如下图</p><p>二，与多页面片对比</p><p>多页面片会将所有依赖项（node_modules）中都打包，所有项目都公用依赖</p><p>三，页面权限校验必须在主项目中进行</p><p>因为主项目是路由控制器，router实例是在主项目中创建的</p><p>四，主项目的 html 如何访问子项目里的编译后的 js / css 等资源</p><p>如果是本地开发时，可以通过 webpack 提供的 proxy，例如：<br>const PROXY = {<br>  ‘/app-a/‘: {<br>    target: ‘<a href="http://localhost:10241/&#39;" target="_blank" rel="noopener">http://localhost:10241/&#39;</a><br>  }<br>};<br>主项目和子项目放在一个文件夹中按照相对路径引用</p><p>五，子项目代码更新后，是否还需要部署主项目</p><p>不需要，项目关联只有main.js，main.js是不需要打包hash值</p><p>六，main.js没有hash值，如何配置缓存</p><p>与max商量了，见main.js打包到特定的目录，例如 nocache/main.js</p><p>七，公共组件如何复用</p><p>公共组件必须抽离到主项目，这样才能项目启动的时候就申明</p><p>八，如何合并目前已有的各个spa项目</p><p>这套方案无法实现，网易云方案是拆分巨无霸项目，单一页面片，单一vue router实例，且只支持一个base配置</p><p>优缺点<br>优点</p><p>子项目可单独打包、单独部署上线，提升了开发和打包的速度<br>子项目之间开发互相独立，互不影响，可在不同仓库进行维护，减少的单个项目的规模<br>保持单页应用的体验，子项目之间切换不刷新<br>改造成本低，对现有项目侵入度较低，业务线迁移成本也较低<br>保证整体项目统一一个技术栈<br>缺点：</p><p>主项目和子项目需要共用一个 Vue 实例，所以无法做到某个子项目单独使用最新版 Vue（例如 Vue3）或者 React</p><p>网易云原创作者教程：<a href="https://juejin.cn/post/6844904079441805326" target="_blank" rel="noopener">https://juejin.cn/post/6844904079441805326</a></p><p>github仓库：<a href="https://github.com/micro-frontends-vue/async-routes" target="_blank" rel="noopener">https://github.com/micro-frontends-vue/async-routes</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微前端也火了很久了，业界的技术方案也有很多种。这玩意吧，确实也是好东西，它能解决什么问题呢？&lt;/p&gt;
&lt;p&gt;本次摘要&lt;/p&gt;
&lt;p&gt;微前端是什么&lt;br&gt;为什么需要微前端&lt;br&gt;对比几种微前端方案&lt;br&gt;简述网易云方案&lt;br&gt;总结&lt;br&gt;常见问题&lt;br&gt;微前端是什么&lt;br&gt;微
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>由vivo自带浏览器的广告拦截引发的bug</title>
    <link href="https://mrdouhua.github.io/2020/10/13/%E7%94%B1vivo%E8%87%AA%E5%B8%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA%E5%BC%95%E5%8F%91%E7%9A%84bug/"/>
    <id>https://mrdouhua.github.io/2020/10/13/%E7%94%B1vivo%E8%87%AA%E5%B8%A6%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%B9%BF%E5%91%8A%E6%8B%A6%E6%88%AA%E5%BC%95%E5%8F%91%E7%9A%84bug/</id>
    <published>2020-10-13T07:33:04.000Z</published>
    <updated>2020-10-13T07:34:13.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在某个项目的信息确认的页面在一部vivo手机的自带浏览器里，detail.js文件加载失败，在其他手机上都是正常的，经过排查，不论是重试加载js，还是更改js顺序，都无法正常加载该js文件。</p><p>最后将打包的文件名修改成confirm.js后，就能够正常加载了，这时候怀疑是浏览器的广告拦截导致的问题。接着将广告拦截关闭，再把文件名改回detail.js后，就能够正常加载该js文件了，现在已经确定是广告拦截将js的加载给阻止了。</p><h2 id="测试vivo的广告拦截策略"><a href="#测试vivo的广告拦截策略" class="headerlink" title="测试vivo的广告拦截策略"></a>测试vivo的广告拦截策略</h2><p>被拦截的js文件为detail.js，然后将这几个文件名排列组合一下，看一下有哪几种组合的js会被拦截。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> script = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">  script[i] = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">  script[i].onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.append(script[i].src + <span class="string">'::加载错误了'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">script[<span class="number">0</span>].src = <span class="string">'/static/lymonTest/dealVerify/js/detail.js'</span></span><br><span class="line">script[<span class="number">1</span>].src = <span class="string">'/static/lymonTest/verify/js/detail.js'</span></span><br><span class="line">script[<span class="number">2</span>].src = <span class="string">'/static/lymonTest/verify/js/detaillist.js'</span></span><br><span class="line">script[<span class="number">3</span>].src = <span class="string">'/static/lymonTest/detail/js/verify.js'</span></span><br><span class="line">script[<span class="number">4</span>].src = <span class="string">'/static/lymonTest/detail/js/verifylist.js'</span></span><br><span class="line">script[<span class="number">5</span>].src = <span class="string">'/static/lymonTest/js/detail.js'</span></span><br><span class="line">script[<span class="number">6</span>].src = <span class="string">'/static/lymonTest/js/verify.js'</span></span><br><span class="line">script[<span class="number">7</span>].src = <span class="string">'/static/lymonTest/js/verifylist.js'</span></span><br><span class="line">script[<span class="number">8</span>].src = <span class="string">'/static/lymonTest/js/detaillist.js'</span></span><br><span class="line"></span><br><span class="line">setTimeout(() =&amp;gt; &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &amp;lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.append(script[i])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>根据上述代码，每个js文件会输出自己的文件名，如果加载失败，则会输出该文件名加载错误。然后我们测试一下在vivo自带浏览器里，有哪几个文件会被阻止加载，结果如下：<br><img src="/tfl/captures/2020-09/tapd_20012601_base64_1600058064_24.png" alt="图片描述"></p><p>由结果可以发现<code>js/detail.js</code>这个路径的js文件会被拦截，其余的则不会，由此可以判断只要是这个路径的js文件，都会发生加载失败的问题。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>项目中打包的文件名，尽量不要用detail这个文件名，防止被拦截加载，vivo的广告拦截策略我们没法查看以及更改，所以只能避免这种情况发生。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;在某个项目的信息确认的页面在一部vivo手机的自带浏览器里，detail.js文件加载失败，在其他手机上都是正常的，经过排查，不论是重试加载
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>由Chrome翻译引出的Vue更新视图失败的问题</title>
    <link href="https://mrdouhua.github.io/2020/10/13/%E7%94%B1Chrome%E7%BF%BB%E8%AF%91%E5%BC%95%E5%87%BA%E7%9A%84Vue%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://mrdouhua.github.io/2020/10/13/%E7%94%B1Chrome%E7%BF%BB%E8%AF%91%E5%BC%95%E5%87%BA%E7%9A%84Vue%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-13T07:31:26.000Z</published>
    <updated>2020-10-13T07:42:14.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在某个项目中，部分电脑上会出现保费以及价值等文本元素在视图上没有发生改变，但是数据是已经更新了的。</p><p>在排查过程中，发现其他的元素的显隐规则是能够正常运行的，并且在更改了保费元素的类型为input元素后，也是能够正常更新视图的。</p><p>在查看页面元素时，发现chrome开启了翻译功能，导致文本元素的节点发生了变化，如下面所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 原元素 --&gt;</span><br><span class="line">&lt;span&gt;12345元&lt;&#x2F;span&gt;</span><br><span class="line">&lt;!-- 翻译过后的元素 --&gt;</span><br><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;font style&#x3D;&quot;vertical-align: inherit&quot;&gt;</span><br><span class="line">    &lt;font style&#x3D;&quot;vertical-align: inherit&quot;&gt;</span><br><span class="line">      12345元</span><br><span class="line">    &lt;&#x2F;font&gt;</span><br><span class="line">  &lt;&#x2F;font&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>这个项目在html文件上没有指定语言为中文，翻译后才会有节点的变化。<br>根据这个元素的变化，初步确定是Vue更新视图时因为元素发生变化，导致无法正常更新视图的问题。</p><h2 id="Vue-patch算法更新视图失败的原因"><a href="#Vue-patch算法更新视图失败的原因" class="headerlink" title="Vue patch算法更新视图失败的原因"></a>Vue patch算法更新视图失败的原因</h2><p>Vue的patch算法，是先对vdom进行比对，判断是相同、新增还是删除节点而做出不同的操作。因为是对vdom进行比对，所以chrome翻译导致的新增节点，无法重新映射回vdom节点。</p><p>所以在比对时，vue会认为本次更新时，这个文本元素只有值的变化，所以最终只更改了span标签下文本节点的textContent，但这时span标签下并没有这个文本节点，所以即使更改了textContent，也是无用的，因为它并不能映射到真实元素上面。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>html需要指定正确的语言，这样在同个语言环境下，即使强行翻译页面，chrome也不会在文本元素下增加新的元素。（但是在不同语言环境下，如果将页面翻译成其他的语言，也依旧会存在视图更新失败的问题）</li><li>将模板语法两个大花括号改为v-text，虽然大部分资料上写的是两个大花括和v-text没有什么区别，但是vue的模板编译和patch算法对这两种语法的处理形式是不同的。<ul><li>模板语法在编译过后，就是一个正常的节点关系，在patch的时候也依赖于vdom和真实dom的对应层级关系。</li><li>v-text编译后本质上是在该节点上将textContent属性和值绑定在一起了，并且在patch时，v-text会将该节点下的子节点都清空，然后再更新textContent属性。这也是为什么Chrome翻译页面后，在文本节点下新增子节点，Vue也能够正常更新视图的原因。</li></ul></li></ol><h3 id="模板语法与v-text编译后的区别"><a href="#模板语法与v-text编译后的区别" class="headerlink" title="模板语法与v-text编译后的区别"></a>模板语法与v-text编译后的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;span&gt;</span><br><span class="line">  &lt;span v-text&#x3D;&quot;msg&quot;&gt;&lt;&#x2F;span&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">with</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">'div'</span>, &#123;</span><br><span class="line">      attrs: &#123;</span><br><span class="line">        <span class="string">"id"</span>: <span class="string">"app"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, [_c(<span class="string">'span'</span>, [_v(_s(msg))]), _c(<span class="string">'span'</span>, &#123;</span><br><span class="line">      domProps: &#123;</span><br><span class="line">        <span class="string">"textContent"</span>: _s(msg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;在某个项目中，部分电脑上会出现保费以及价值等文本元素在视图上没有发生改变，但是数据是已经更新了的。&lt;/p&gt;
&lt;p&gt;在排查过程中，发现其他的元
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>垃圾回收机制</title>
    <link href="https://mrdouhua.github.io/2020/10/13/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://mrdouhua.github.io/2020/10/13/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</id>
    <published>2020-10-13T07:28:37.000Z</published>
    <updated>2020-10-13T07:28:57.052Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JS的回收机制分两种：1.标记清除 2.引用计数。各大浏览器常用的是前者。</strong>  </p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>定义和用法：当变量进入环境时，将变量标记”进入环境”，当变量离开环境时，标记为：”离开环境”。某一个时刻，垃圾回收器会过滤掉环境中的变量，以及被环境变量引用的变量，剩下的就是被视为准备回收的变量。  </p><p>工作流程：</p><ol><li><p>垃圾回收器，在运行的时候会给存储在内存中的所有变量都加上标记。</p></li><li><p>去掉环境中的变量以及被环境中的变量引用的变量的标记。</p></li><li><p>再被加上标记的会被视为准备删除的变量。</p></li><li><p>垃圾回收器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。</p></li></ol><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>定义和用法：引用计数是跟踪记录每个值被引用的次数。</p><p>　　基本原理：就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象。</p><p>工作流程：</p><ol><li><p>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型值的引用次数就是1。</p></li><li><p>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1.</p></li><li><p>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1.</p></li><li><p>当引用次数变成0时，说明没办法访问这个值了。</p></li><li><p>当垃圾收集器下一次运行时，它就会释放引用次数是0的值所占的内存。</p></li></ol><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>循环引用的时候就会释放不掉内存。循环引用就是对象A中包含另一个指向对象B的指针，B中也包含一个指向A的引用。</p><p>开发过程中遇到的内存泄露情况<br>1、定义和用法：</p><p>内存泄露是指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。C#和Java等语言采用了自动垃圾回收方法管理内存，几乎不会发生内存泄露。我们知道，浏览器中也是采用自动垃圾回收方法管理内存，但由于浏览器垃圾回收方法有bug，会产生内存泄露。</p><p>由于每次的垃圾回收开销都相对较大，并且由于机制的一些不完善的地方，可能会导致内存泄露。我们可以利用一些方法减少垃圾回收，并且尽量避免循环引用的问题。</p><p>例如，在对象结束使用后 ，令obj=null。这样利于解除循环引用，使得无用变量及时被回收</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JS的回收机制分两种：1.标记清除 2.引用计数。各大浏览器常用的是前者。&lt;/strong&gt;  &lt;/p&gt;
&lt;h3 id=&quot;标记清除&quot;&gt;&lt;a href=&quot;#标记清除&quot; class=&quot;headerlink&quot; title=&quot;标记清除&quot;&gt;&lt;/a&gt;标记清除&lt;/h3&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>常用数据结构</title>
    <link href="https://mrdouhua.github.io/2020/10/13/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://mrdouhua.github.io/2020/10/13/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</id>
    <published>2020-10-13T07:23:34.000Z</published>
    <updated>2020-10-13T09:43:01.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="js基本类型与引用类型的区别"><a href="#js基本类型与引用类型的区别" class="headerlink" title="js基本类型与引用类型的区别"></a>js基本类型与引用类型的区别</h2><p>基本类型有：undefined，boolean，number，string，null<br>引用类型有：Object，Array，Date等  </p><p>基本类型的变量是存放在栈区的（栈区指内存里的栈内存），栈区包括了 变量的标识符和变量的值。<br><img src="https://images2015.cnblogs.com/blog/1103385/201702/1103385-20170212104752057-1066946645.png" alt="image"></p><p>引用类型的值是同时保存在栈内存和堆内存中的对象，栈区内存保存变量标识符和指向堆内存中该对象的指针<br><img src="https://images2015.cnblogs.com/blog/1103385/201702/1103385-20170212104829307-1264699054.png" alt="image"></p><h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2><p>常用的数据结构有：数组，栈，链表，队列，树，图，堆，散列表等<br><img src="https://img-blog.csdn.net/20180903194901687?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lleWF6aGlzaGFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><h3 id="1、数组"><a href="#1、数组" class="headerlink" title="1、数组"></a>1、数组</h3><p>数组是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问  </p><h3 id="2、栈"><a href="#2、栈" class="headerlink" title="2、栈"></a>2、栈</h3><p>栈是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。 栈的特点是：先进后出，或者说是后进先出，从栈顶放入元素的操作叫入栈，取出元素叫出栈。<br><img src="https://img-blog.csdn.net/20180903195046375?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lleWF6aGlzaGFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"></p><h3 id="3、队列"><a href="#3、队列" class="headerlink" title="3、队列"></a>3、队列</h3><p>队列与栈一样，也是一种线性表，不同的是，队列可以在一端添加元素，在另一端取出元素，也就是：先进先出。从一端放入元素的操作称为入队，取出元素为出队。<br>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p><h3 id="4、链表"><a href="#4、链表" class="headerlink" title="4、链表"></a>4、链表</h3><p>链表是物理存储单元上非连续的、非顺序的存储结构，数据元素的逻辑顺序是通过链表的指针地址实现，每个元素包含两个结点，一个是存储元素的数据域 (内存空间)，另一个是指向下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。<br>所谓的双向链表，只是加了一个向前的线索的链表而已。  </p><h3 id="5、树"><a href="#5、树" class="headerlink" title="5、树"></a>5、树</h3><p>由n（n&gt;=1）个有限节点组成一个具有层次关系的集合，特点：</p><ul><li>每个节点有零个或多个子节点；</li><li>没有父节点的节点称为根节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ul><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p><img src="https://img-blog.csdn.net/20180903195345210?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lleWF6aGlzaGFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="image"><br>二叉树是树的特殊一种，具有如下特点：</p><p>1、每个结点最多有两颗子树，结点的度最大为2。<br>2、左子树和右子树是有顺序的，次序不能颠倒。<br>3、即使某结点只有一个子树，也要区分左右子树。  </p><h3 id="6、散列表-哈希表"><a href="#6、散列表-哈希表" class="headerlink" title="6、散列表/哈希表"></a>6、散列表/哈希表</h3><p>关键码和值 (key和value) 直接进行访问的数据结构</p><h3 id="7、堆"><a href="#7、堆" class="headerlink" title="7、堆"></a>7、堆</h3><p>堆是一种比较特殊的数据结构，可以被看做一棵树的数组对象，具有以下的性质：</p><ul><li>堆中某个节点的值总是不大于或不小于其父节点的值；</li><li>堆总是一棵完全二叉树。</li></ul><h3 id="8、图"><a href="#8、图" class="headerlink" title="8、图"></a>8、图</h3><p>图是由结点的有穷集合V和边的集合E组成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;js基本类型与引用类型的区别&quot;&gt;&lt;a href=&quot;#js基本类型与引用类型的区别&quot; class=&quot;headerlink&quot; title=&quot;js基本类型与引用类型的区别&quot;&gt;&lt;/a&gt;js基本类型与引用类型的区别&lt;/h2&gt;&lt;p&gt;基本类型有：undefined，boolea
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>原生js封装ajax</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E5%8E%9F%E7%94%9Fjs%E5%B0%81%E8%A3%85ajax/</id>
    <published>2020-06-30T12:27:21.630Z</published>
    <updated>2020-06-30T12:28:27.156Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function ajax (options) &#123;</span><br><span class="line">    let xhr &#x3D; null</span><br><span class="line">    if ((window.XMLHttpRequest) &#123;</span><br><span class="line">        xhr &#x3D; new XMLHttpRequest()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; IE6及其以下版本</span><br><span class="line">        xhr &#x3D; new ActiveXObjcet(&#39;Microsoft.XMLHTTP&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">        if(xhr.readyState &#x3D;&#x3D; 4) &#123;</span><br><span class="line">            let status &#x3D; xhr.status;</span><br><span class="line">            if ((status &gt;&#x3D; 200 &amp;&amp; status &lt; 300) || status &#x3D;&#x3D;&#x3D; 304) &#123;</span><br><span class="line">                options.success &amp;&amp; options.success()</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                options.error &amp;&amp; options.error()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let type &#x3D; (options.type || &#39;GET&#39;).toUpperCase() &#x2F;&#x2F; 转为大写</span><br><span class="line">    if (type &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;</span><br><span class="line">        let url &#x3D; xhr.url + &#39;?&#39; + formatParams(option.data)</span><br><span class="line">        xhr.open(type, url, true)</span><br><span class="line">        xhr.send(null)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        xhr.open(type, url, true)</span><br><span class="line">        &#x2F;&#x2F;设置提交时的内容类型</span><br><span class="line">        xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded; charset&#x3D;UTF-8&#39;);</span><br><span class="line">        xhr.send(option.data)</span><br><span class="line">    &#125;</span><br><span class="line">    function formatParams (data) &#123;</span><br><span class="line">        var arr &#x3D; [];</span><br><span class="line">        for(var name in data) &#123;</span><br><span class="line">          arr.push(name + &#39;&#x3D;&#39; + data[name]);</span><br><span class="line">        &#125;;</span><br><span class="line">        &#x2F;&#x2F; 添加一个随机数，防止缓存</span><br><span class="line">        arr.push(&#39;v&#x3D;&#39; + Math.floor(Math.random() * 10000 + 500));</span><br><span class="line">        return arr.join(&#39;&amp;&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>防抖与节流</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</id>
    <published>2020-06-30T11:48:17.691Z</published>
    <updated>2020-06-30T11:48:51.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>解释：当持续触发某事件时，一定时间间隔内没有再触发事件时，事件处理函数才会执行一次，如果设定的时间间隔到来之前，又一次触发了事件，就重新开始延时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fn, wait) &#123;</span><br><span class="line">    let timeout &#x3D; null &#x2F;&#x2F; 借助闭包</span><br><span class="line">    return function () &#123;</span><br><span class="line">        if (timeout) clearTimeout(timeout)</span><br><span class="line">        timeout &#x3D; setTimeout(fn, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">function handle() &#123;  </span><br><span class="line">    console.log(Math.random())</span><br><span class="line">&#125;</span><br><span class="line">window.addEventListener(&#39;scroll&#39;, debounce(handle, 1000))</span><br></pre></td></tr></table></figure><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>当持续触发事件时，有规律的每隔一个时间间隔执行一次事件处理函数。如果规定时间内触发了事件，不执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function throttle (fn, wait) &#123;</span><br><span class="line">    let flag &#x3D; false</span><br><span class="line">    return function () &#123;</span><br><span class="line">        if (flag) &#123;</span><br><span class="line">            return false</span><br><span class="line">        &#125;</span><br><span class="line">        flag &#x3D; true</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">          flag &#x3D; false</span><br><span class="line">          fn()</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;防抖&quot;&gt;&lt;a href=&quot;#防抖&quot; class=&quot;headerlink&quot; title=&quot;防抖&quot;&gt;&lt;/a&gt;防抖&lt;/h2&gt;&lt;p&gt;解释：当持续触发某事件时，一定时间间隔内没有再触发事件时，事件处理函数才会执行一次，如果设定的时间间隔到来之前，又一次触发了事件，就重新开始
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSS基本布局篇</title>
    <link href="https://mrdouhua.github.io/2020/06/30/CSS%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E7%AF%87/"/>
    <id>https://mrdouhua.github.io/2020/06/30/CSS%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80%E7%AF%87/</id>
    <published>2020-06-30T02:26:57.811Z</published>
    <updated>2020-06-30T02:27:26.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h2><p>很多方法都会受浮动影响</p><ul><li><p>单行已知宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text-align:center;</span><br><span class="line">inline-height: 50px;</span><br></pre></td></tr></table></figure></li><li><p>已知字元素宽高</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    position: reletive;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute&#x2F;relative;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    margin: -50px 0 0 -50px;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>margin:auto;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent&#123;</span><br><span class="line">    position: reletive;</span><br><span class="line">&#125;</span><br><span class="line">.child &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 0;</span><br><span class="line">    top: 0;</span><br><span class="line">    tight: 0;</span><br><span class="line">    b0ttom: 0;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin:auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>未知宽高<br>用css3 transform: translate(-50%, -50%);</p></li><li><p>table-cell表格实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display: table-cell;</span><br><span class="line">vertical-align: middle;</span><br><span class="line">text-align: center;</span><br></pre></td></tr></table></figure></li></ul><h2 id="两栏布局"><a href="#两栏布局" class="headerlink" title="两栏布局"></a>两栏布局</h2><ul><li>浮动<br>left左浮动，right不浮动，margin/padding-left</li><li>绝对定位<br>方式和浮动一样</li><li>表格布局<br>wrap: table, child:table-cell</li><li>flex布局</li></ul><h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><p>1、将middle首先放在container的子元素第一个，然后是left，right,同时设置三者float:left；</p><p>2、middle要自适应，需要设置width:100%；让left部分和middle处于一行，要是用margin-left:-100%;</p><p>3、此时left部分会遮盖middle的内容，将middle部分收缩起来，设置其父元素container内边距，padding：0 200px;</p><p>4、left部分内容随同middle收缩，占据middle一部分，需要设置left部分使用相对定位，独立于middle，left:-200px;</p><p>5、同理right部分放置middle右部分，需要设置其相对定位、宽度和margin-left、right值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;圣杯布局&lt;&#x2F;title&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">　　body&#123;</span><br><span class="line">　　　　margin:auto;</span><br><span class="line">　　　　text-align: center;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.container&#123;</span><br><span class="line">　　　　overflow: hidden;</span><br><span class="line">　　　　margin:10px 0;</span><br><span class="line">　　　　padding: 0 200px 0 205px;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.left&#123;</span><br><span class="line">　　　　float: left;</span><br><span class="line">　　　　position: relative;</span><br><span class="line">　　　　margin-left: -100%;</span><br><span class="line">　　　　left: -210px;</span><br><span class="line">　　　　width: 205px;</span><br><span class="line">　　　　background-color:grey;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.middle&#123;</span><br><span class="line">　　　　float: left;</span><br><span class="line">　　　　width: 100%;</span><br><span class="line">　　　　background-color: red;</span><br><span class="line">　　&#125;</span><br><span class="line">　　.right&#123;</span><br><span class="line">　　　　right: -210px;</span><br><span class="line">　　　　margin-left: -205px;</span><br><span class="line">　　　　width: 200px;</span><br><span class="line">　　　　float: left;</span><br><span class="line">　　　　position: relative;</span><br><span class="line">　　　　background-color: grey;</span><br><span class="line">　　&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">　　&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">　　　　&lt;div class&#x3D;&quot;middle&quot;&gt;middle&lt;&#x2F;div&gt;</span><br><span class="line">　　　　&lt;div class&#x3D;&quot;left&quot;&gt;left&lt;&#x2F;div&gt;</span><br><span class="line">　　　　&lt;div class&#x3D;&quot;right&quot;&gt;right&lt;&#x2F;div&gt;</span><br><span class="line">　　&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">## 双飞翼布局</span><br><span class="line">1、将middle首先放在container的子元素第一个，然后是left，right,同时设置三者float:left；</span><br><span class="line"></span><br><span class="line">2、middle要自适应，需要设置width:100%；让left部分和middle处于一行，要是用margin-left:-100%;，right使用margin-left:-190px;</span><br><span class="line"></span><br><span class="line">3、此时middle的内容被覆盖，要把middle的内容拉出来，除了使用外围container的padding，还可以考虑使用margin，给middle增加一个内层div -- middle_content, 然后设置 margin:0 200px</span><br></pre></td></tr></table></figure><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <meta http-equiv="X-UA-Compatible" content="ie=edge">    <title>Document</title><meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="莫克力学习博客" type="application/atom+xml"></head><body>    <div class="wrapper">        <div class="main">            <div class="inner">                main            </div>        </div>        <div class="left">left</div>        <div class="right">right</div>    </div>     <style>        .main,.left,.right{            height: 100px;            float: left;        }        .main{            width: 100%;            background-color: aqua;        }        .left{            width:120px;            margin-left: -100%;            background-color:cornflowerblue;        }        .right{            width: 120px;            margin-left: -120px;            background-color: cadetblue;        }        .inner{            margin-left:120px;            margin-right: 120px;        }     </style></body>```## flex布局- display:flex/inline-flex  - flex-direction  主轴方向  - flex-wrap  是否换行    - nowrap 不换行    - wrap  换行    - wrap-reverse  换行，第一行在上方  - flex-flow  是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap  - justify-content  水平方向排列    - flex-start    - flex-end    - center    - space-between    - space-around  - align-items  垂直方向      - flex-start    - flex-end    - center    - baseline    - stretch  - align-content  根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<ul><li>子元素的属性<ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;水平垂直居中&quot;&gt;&lt;a href=&quot;#水平垂直居中&quot; class=&quot;headerlink&quot; title=&quot;水平垂直居中&quot;&gt;&lt;/a&gt;水平垂直居中&lt;/h2&gt;&lt;p&gt;很多方法都会受浮动影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;单行已知宽高&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>webpack学习</title>
    <link href="https://mrdouhua.github.io/2020/06/30/webpack%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mrdouhua.github.io/2020/06/30/webpack%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-30T02:26:23.620Z</published>
    <updated>2020-06-30T02:26:44.601Z</updated>
    
    <content type="html"><![CDATA[<p>webpack概念</p><ul><li>entry</li><li>output</li><li>loader</li><li>plugin</li><li>optimization // webpack4</li><li>externals</li><li>mode<br>development 或 production</li></ul><h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>单页面入口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: &#39;.&#x2F;src&#x2F;pageOne&#x2F;index.js&#39;,</span><br><span class="line">    pageTwo: &#39;.&#x2F;src&#x2F;pageTwo&#x2F;index.js&#39;,</span><br><span class="line">    pageThree: &#39;.&#x2F;src&#x2F;pageThree&#x2F;index.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多页面片</p><blockquote><p>filename 用于输出文件的文件名。<br>目标输出目录 path 的绝对路径。  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageOne: &#39;.&#x2F;src&#x2F;pageOne&#x2F;index.js&#39;,</span><br><span class="line">    pageTwo: &#39;.&#x2F;src&#x2F;pageTwo&#x2F;index.js&#39;,</span><br><span class="line">    pageThree: &#39;.&#x2F;src&#x2F;pageThree&#x2F;index.js&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const config &#x3D; &#123;</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;bundle.js&#39;,</span><br><span class="line">    path: &#39;&#x2F;home&#x2F;proj&#x2F;public&#x2F;assets&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; config;</span><br></pre></td></tr></table></figure><p>多页面片入口起点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;app.js&#39;,</span><br><span class="line">    search: &#39;.&#x2F;src&#x2F;search.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    path: __dirname + &#39;&#x2F;dist&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="mode-模式"><a href="#mode-模式" class="headerlink" title="mode 模式"></a>mode 模式</h2><p>提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  mode: &#39;production&#39;</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">或者从 CLI 参数中传递：  </span><br><span class="line">webpack --mode&#x3D;production</span><br></pre></td></tr></table></figure><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换。loader 可以使你在 import 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你直接在 JavaScript 模块中 import CSS文件！  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123; test: &#x2F;\.css$&#x2F;, use: &#39;css-loader&#39; &#125;,</span><br><span class="line">      &#123; test: &#x2F;\.ts$&#x2F;, use: &#39;ts-loader&#39; &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="插件-plugins"><a href="#插件-plugins" class="headerlink" title="插件(plugins)"></a>插件(plugins)</h2><p>插件目的在于解决 loader 无法实现的其他事  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    new HtmlWebpackPlugin(&#123;template: &#39;.&#x2F;src&#x2F;index.html&#39;&#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><h2 id="构建目标-targets"><a href="#构建目标-targets" class="headerlink" title="构建目标(targets)"></a>构建目标(targets)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  target: &#39;node&#39; &#x2F;&#x2F; 默认为web</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="devServer本地服务器"><a href="#devServer本地服务器" class="headerlink" title="devServer本地服务器"></a>devServer本地服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">        contentBase: &quot;.&#x2F;dist&quot;, &#x2F;&#x2F; 本地服务器所加载文件的目录</span><br><span class="line">        port: &quot;8088&quot;,  &#x2F;&#x2F; 设置端口号为8088</span><br><span class="line">        inline: true, &#x2F;&#x2F; 文件修改后实时刷新</span><br><span class="line">        historyApiFallback: true, &#x2F;&#x2F;不跳转</span><br><span class="line">        hot: true &#x2F;&#x2F; 热更新</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="模块热替换"><a href="#模块热替换" class="headerlink" title="模块热替换"></a>模块热替换</h2><p>HMR  </p><h2 id="Source-Maps调试配置"><a href="#Source-Maps调试配置" class="headerlink" title="Source Maps调试配置"></a>Source Maps调试配置</h2><p>作为开发，代码调试当然少不了，那么问题来了，经过打包后的文件，你是不容易找到出错的地方的，Source Map就是用来解决这个问题的</p><h4 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h4><p>在任何模块文件内部，可以使用__dirname变量获取当前模块文件所在目录的完整绝对路径。  </p><p>配置：  </p><h4 id="configureWebpack"><a href="#configureWebpack" class="headerlink" title="configureWebpack"></a>configureWebpack</h4><blockquote><p>如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。<br>如果这个值是一个函数，则会接收被解析的配置作为参数。该函数既可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。  </p></blockquote><h2 id="Runtime"><a href="#Runtime" class="headerlink" title="Runtime"></a>Runtime</h2><p>在浏览器运行时，webpack 用来连接模块化的应用程序的所有代码。runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。  </p><h2 id="Manifest"><a href="#Manifest" class="headerlink" title="Manifest"></a>Manifest</h2><p>当编译器(compiler)开始执行、解析和映射应用程序时，它会保留所有模块的详细要点。这个数据集合称为 “Manifest”，当完成打包并发送到浏览器时，会在运行时通过 Manifest 来解析和加载模块。无论你选择哪种模块语法，那些 import 或 require 语句现在都已经转换为 <strong>webpack_require</strong> 方法  </p><p>webpack.optimize.CommonsChunkPlugin来帮我们分离代码，将mainfest、第三方库包，业务代码独立成三个文件  </p><p>1.runtime</p><p>在浏览器运行时,webpack用来连接模块化的应用程序的所有代码 runtime包含:</p><p>在模块交互时,连接模块所需的加载和解析逻辑<br>包括浏览器中的已加载模块的连接,以及懒加载模块的执行逻辑  </p><p>2.manifest</p><p>manifest数据用来管理生成的index.html文件和bundle以及各种资源,把他们加载到浏览器中</p><p>当编译器开始执行、解析和映射应用程序,会保留所有模块的详细要点. 这个集合称为Manifest</p><p>打包完成发送到浏览器 运行时通过Manifest来解析和加载模块 import 或require语句转换为 webpack require 方法 此方法指向模块标识符 通过manifest 中的数据 runtime 将能够查询模块标识符,检索出背后对应的模块</p><h4 id="chainWebpack"><a href="#chainWebpack" class="headerlink" title="chainWebpack"></a>chainWebpack</h4><p>是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。</p><h2 id="webpack3和webpack4对比"><a href="#webpack3和webpack4对比" class="headerlink" title="webpack3和webpack4对比"></a>webpack3和webpack4对比</h2><p>1.替换插件 extract-text-webpack-plugin，使用 webpack4 推荐使用的插件mini-css-extract-plugin<br>2.在 webpack4 中不再支持 CommonsChunkPlugin，而是使用 splitChunks 替代  </p><ul><li>CommonsChunkPlugin 会提取一些我们不需要的代码  </li><li>它在异步模块上效率低下</li><li>splitChunks它不会打包不需要的模块</li><li>splitChunks对异步模块有效（默认情况下是打开的）<br>webpack 4 已经废除了 之前 UglifyJsPlugin,用 optimization.minimize 替代  <h2 id="vue-cli3使用"><a href="#vue-cli3使用" class="headerlink" title="vue-cli3使用"></a>vue-cli3使用</h2></li></ul><h2 id="webpack多页面片"><a href="#webpack多页面片" class="headerlink" title="webpack多页面片"></a>webpack多页面片</h2><p>webpack3/4大致差不多，只是部分插件不一样</p><ul><li>entry单页面片 ‘./src/index.html’，多页面片<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &#39;.&#x2F;src&#x2F;app.js&#39;,</span><br><span class="line">    search: &#39;.&#x2F;src&#x2F;search.js&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#39;[name].js&#39;,</span><br><span class="line">    path: __dirname + &#39;&#x2F;dist&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>htmlWebpackPlugins</li><li>使用 CommonsChunkPlugin 为每个页面间的应用程序共享代码创建 bundle。由于入口起点增多，多页应用能够复用入口起点之间的大量代码/模块，从而可以极大地从这些技术中受益。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;webpack概念&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;entry&lt;/li&gt;
&lt;li&gt;output&lt;/li&gt;
&lt;li&gt;loader&lt;/li&gt;
&lt;li&gt;plugin&lt;/li&gt;
&lt;li&gt;optimization // webpack4&lt;/li&gt;
&lt;li&gt;externals&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>2019腾讯前端技术大会----SSR学习</title>
    <link href="https://mrdouhua.github.io/2020/06/30/2019%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A----SSR%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mrdouhua.github.io/2020/06/30/2019%E8%85%BE%E8%AE%AF%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%A4%A7%E4%BC%9A----SSR%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-30T02:19:10.659Z</published>
    <updated>2020-10-13T09:43:07.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>进入页面loading加载状态，页面白屏时间长<br>原因是客户端渲染：html 仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接以原文件的形式返回给客户端客户端，然后根据 html 上的 JavaScript，生成 DOM 插入 html。  </p><p>前端渲染的方式起源于JavaScript的兴起，ajax的大热更是让前端渲染更加成熟，前端渲染真正意义上的实现了前后端分离，前端只专注于UI的开发，后端只专注于逻辑的开发，前后端交互只通过约定好的API来交互，后端提供json数据，前端循环json生成DOM插入到页面中去。 </p><p>好处： 网络传输数据量小、减少了服务器压力、前后端分离、局部刷新，无需每次请求完整页面、交互好可实现各种效果  </p><p>坏处：不利于SEO、爬虫看不到完整的程序源码、首屏渲染慢（渲染前需要下载一堆js和css等）  </p><h3 id="SSR是什么"><a href="#SSR是什么" class="headerlink" title="SSR是什么"></a>SSR是什么</h3><p>服务端渲染（SSR：server side render）<br>将页面通过服务器生成html字符串，再发送到浏览器</p><p>怎么理解SSR<br>首先，我们需要有一份同构代码，这部分代码和我们之前写的前端代码是基本一致的。然后，因为需要服务端渲染，所以服务端需要有一份同构代码打包后的js bundle，前端不必多说，天生需要一份。要注意的是，这两份是不同的bundle，因为server端和client端虽然都是做渲染工作，他们做的事情是有不同的，下面细说。然后经过中间的webpack打包后部署。接下来，请求到来，node server收到请求后，用server bundle作为入口拿到一份前端代码，render成html后返回给前端。前端收到后，就可以把预渲染的html展示给用户拉！！！就这么利索。但是前端还会去下载前端的bundle，然后以此为入口，激活后端返回的html，然后此时你的站点就完全可交互了！完美~  </p><p>服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成 HTML 字符串，然后把它返回给客户端。客户端拿到手的，是可以直接渲染然后呈现给用户的 HTML 内容，不需要为了生成 DOM 内容自己再去跑一遍 JS 代码。使用服务端渲染的网站，可以说是“所见即所得”，页面上呈现的内容，我们在 html 源文件里也能找到。</p><p>渲染：就是将数据和模版组装成html  </p><h3 id="SSR的优点与缺点"><a href="#SSR的优点与缺点" class="headerlink" title="SSR的优点与缺点"></a>SSR的优点与缺点</h3><ul><li>优点<ul><li>更利于SEO<ul><li>通过AJAX加载页面数据的，很难保证站内数据被SEO获取到</li><li>更好的SEO，我们可以将SEO的关键数据直接在后台就渲染成html，从而保证搜索引擎的爬虫能爬取到关键数据</li><li>由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</li></ul></li><li>更利于首屏渲染  <ul><li>服务器端请求首屏数据而不是客户端请求首屏数据，服务器端在内网进行请求，速度更快。但是客户端处于不同的网络环境，导致时间差</li></ul></li></ul></li><li>缺点<ul><li>服务器压力大，考虑服务器端负载。</li><li>学习成本增大，需要学习构建设置和部署的更多要求</li><li>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</li></ul></li></ul><p>由于没有动态更新，所有的生命周期钩子函数中，只有 beforeCreate 和 created 会在服务器端渲染 (SSR) 过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 beforeMount 或 mounted），只会在客户端执行。</p><p>SSR与CSR对比<br>serverless如何解决SSR开发成本高的问题的<br>fass是什么，怎么使用<br>FaaS 可以将函数作为一个线上服务、远程计算服务，可以通过 API 执行、通过邮件执行、通过 Iot 执行，通过队列执行。你只需要写统一的函数就行了。<br>你要做的只是写下如下这样的函数，然后再用配置文件告诉服务器如何让他运行，就完事了，你的所有工作都在这个函数内完成。</p><p><img src="https://img-blog.csdnimg.cn/20190712222152121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzg0Mzc5,size_16,color_FFFFFF,t_70" alt="image"></p><h3 id="如何做到极致的SSR"><a href="#如何做到极致的SSR" class="headerlink" title="如何做到极致的SSR"></a>如何做到极致的SSR</h3><h3 id="是否需要使用SSR"><a href="#是否需要使用SSR" class="headerlink" title="是否需要使用SSR"></a>是否需要使用SSR</h3><p>这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。</p><h3 id="服务器端渲染-vs-预渲染-SSR-vs-Prerendering"><a href="#服务器端渲染-vs-预渲染-SSR-vs-Prerendering" class="headerlink" title="服务器端渲染 vs 预渲染 (SSR vs Prerendering)"></a>服务器端渲染 vs 预渲染 (SSR vs Prerendering)</h3><p>vue ssr解读<br>避免状态单例  </p><p>许多 webpack 特定功能不能直接在 Node.js 中运行（例如通过 file-loader 导入文件，通过 css-loader 导入 CSS）  </p><p>所以基本看法是，对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包 - 服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记。  </p><p>在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的”快照”，所以如果应用程序依赖于一些异步数据，那么在开始渲染过程之前，需要先预取和解析好这些数据。  </p><p>使用双花括号(double-mustache)进行 HTML 转义插值(HTML-escaped interpolation)，以避免 XSS 攻击。  </p><p>asyncData是干嘛用的？其实，这个函数是专门请求数据用的，你可能会问请求数据为什么不在beforeCreate或者created中完成，还要专门定义一个函数？虽然beforeCreate和created在服务端也会被执行（其他周期函数只会在客户端执行），但是我们都知道请求是异步的，这就导致请求发出后，数据还没返回，渲染就已经结束了，所以无法把 Ajax 返回的数据也一并渲染出来。因此需要想个办法，等到所有数据都返回后再渲染组件</p><p>在 2.3.2+ 的版本，你可以通过 this.$ssrContext 来直接访问组件中的服务器端渲染上下文(SSR context)  </p><p>如果您唯一关注的是SEO，那么随时都可以轻松使用预渲染。 </p><h3 id="流式渲染-Streaming"><a href="#流式渲染-Streaming" class="headerlink" title="流式渲染 (Streaming)"></a>流式渲染 (Streaming)</h3><p>对于 vue-server-renderer 的基本 renderer 和 bundle renderer 都提供开箱即用的流式渲染功能。所有你需要做的就是，用 renderToStream 替代 renderToString：  </p><h3 id="非NodeJs中使用SSR"><a href="#非NodeJs中使用SSR" class="headerlink" title="非NodeJs中使用SSR"></a>非NodeJs中使用SSR</h3><p>对于所有环境，必须要预先在环境中模拟 global 和 process 对象，以及将 process.env.VUE_ENV 设置为 “server” 和将 process.env.NODE_ENV 设置为 “development” 或 “production”。  </p><p>phpV8js中使用，V8Js是Google V8 Javascript引擎的PHP扩展，那这个插件是在php中模拟V8引擎，然后可以运行js代码  </p><p>process 对象：process对象是Node.js中非常重要的一个全局对象，它是一个与操作系统集成的对象，使用process我们可以进行许多与操作系统打交道的工作  </p><h4 id="serverless-与-faas"><a href="#serverless-与-faas" class="headerlink" title="serverless 与 faas"></a>serverless 与 faas</h4><p>Serverless架构<br>Serverless（无服务器架构）指的是由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发， 完全被第三方管理，其业务层面的状态则被开发者使用的数据库和存储资源所记录。  </p><h5 id="Serverless架构主要有以下特点："><a href="#Serverless架构主要有以下特点：" class="headerlink" title="Serverless架构主要有以下特点："></a>Serverless架构主要有以下特点：</h5><p>实现了细粒度的计算资源分配。<br>不需要预先分配资源。<br>具备真正意义上的高度扩容和弹性。<br>按需使用，按需计费。  </p><p>FaaS函数即服务？  </p><p>专注于单一责任与功能的小型功能块为基础，利用模组化的方式组合出复杂的大型应用程序<br>Function as a Services（FaaS）。而所谓的“函数”（Function）提供的是相比微服务更加细小的程序单元。例如用户的创建、读取等操作 </p><p>PaaS（Platform as a Service  </p><p>Q 一般SSR首次绘制(FP: First Paint)慢, 不能渐进式加载<br>A HTTP1.1 分块传输可以完美的解决这个问题<br>Transfer-Encoding: chunked<br>HTTP2:   数据帧  </p><p>Q SSR页面切换无法渐进式加载， 不能定义页面切换动画<br>A 无刷新切换：直出单页应用运用前端路由管理模块，页面无刷新切换的页面状态， 可自定义切换动效。<br>Q 怎么理解serveless和fass，按需执行、弹性伸缩是什么意思</p><p>Q 流式渲染与分块传输区别，二者分别是什么意思<br>依赖由组件生命周期钩子函数填充的上下文数据，则不建议使用流式传输模式  </p><p>Q 服务端只有beforeCreate 和 created两个生命周期吗<br>A 已证明 是的</p><p>Q1，如何应用到小雨伞中<br>Q2，相比于加载单页应用，我只需要加载当前页面的内容，而不需要像 React 或者 Vue 一样加载全部的 js 文件 </p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>vue ssr <a href="https://ssr.vuejs.org/zh/" target="_blank" rel="noopener">https://ssr.vuejs.org/zh/</a><br><a href="https://www.jianshu.com/p/b8cfa496b7ec" target="_blank" rel="noopener">https://www.jianshu.com/p/b8cfa496b7ec</a>  简书<br><a href="https://www.jdon.com/50088" target="_blank" rel="noopener">https://www.jdon.com/50088</a> SSR问题<br><a href="https://segmentfault.com/a/1190000015964813?utm_source=tag-newest" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015964813?utm_source=tag-newest</a>  原理解读<br><a href="https://blog.csdn.net/vhwfr2u02q/article/details/83005905" target="_blank" rel="noopener">https://blog.csdn.net/vhwfr2u02q/article/details/83005905</a>  vue ssr 不可不知的问题<br><a href="https://ke.qq.com/course/package/20989?tuin=37f476dd" target="_blank" rel="noopener">https://ke.qq.com/course/package/20989?tuin=37f476dd</a> 视频回放  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;进入页面loading加载状态，页面白屏时间长&lt;br&gt;原因是客户端渲染：html 仅仅作为静态文件，客户端在请求时，服务端不做任何处理，直接
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>手机端使用audio遇到的问题</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E6%89%8B%E6%9C%BA%E7%AB%AF%E4%BD%BF%E7%94%A8audio%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E6%89%8B%E6%9C%BA%E7%AB%AF%E4%BD%BF%E7%94%A8audio%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-06-30T02:17:33.282Z</published>
    <updated>2020-06-30T02:17:49.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>比较安卓与iOS端audio使用的差异，主要解决ios的兼容性问题  </p><h4 id="数据加载完成时的事件"><a href="#数据加载完成时的事件" class="headerlink" title="数据加载完成时的事件"></a>数据加载完成时的事件</h4><p>两个终端可播放的事件不一样，所以可以在做兼容时区分一下终端  </p><ul><li>安卓<br>loadedmetadata，当浏览器已加载音频/视频的元数据时  </li><li>iOS<br>canplaythrough，当浏览器可在不因缓冲而停顿的情况下进行播放时  </li></ul><h4 id="ios预加载和首次自动播放的问题"><a href="#ios预加载和首次自动播放的问题" class="headerlink" title="ios预加载和首次自动播放的问题"></a>ios预加载和首次自动播放的问题</h4><p>安卓端可以在页面初始化进行资源的加载，并且可以出发播放器的播放事件，不会用问题。但是ios就不一样了。<br>iOS端的媒体资源的加载与首次自动播放必须在微信端weixinJsBridgeReady事件中进行，获取通过用户手动出发的事件中进行，该事件也不可通过我们js模拟。  </p><h4 id="多个媒体资源需要连续播放时不能复用播放器"><a href="#多个媒体资源需要连续播放时不能复用播放器" class="headerlink" title="多个媒体资源需要连续播放时不能复用播放器"></a>多个媒体资源需要连续播放时不能复用播放器</h4><p>比如我们需要连续播放多个语音，就不能只创建一个audio标签，因为每次加载都需动态改变播放链接，然后执行load进行下载，那么这个下载过程可能让用户等很久。并且在iOS端，会有加载两次的bug。<br>解决方案就是为每一条音频都动态创建一个播放标签，动态加载资源。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;比较安卓与iOS端audio使用的差异，主要解决ios的兼容性问题  &lt;/p&gt;
&lt;h4 id=&quot;数据加载完成时的事件&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>vue3.0学习</title>
    <link href="https://mrdouhua.github.io/2020/06/30/vue3.0%E5%AD%A6%E4%B9%A0/"/>
    <id>https://mrdouhua.github.io/2020/06/30/vue3.0%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-06-30T02:16:37.643Z</published>
    <updated>2020-06-30T02:16:55.411Z</updated>
    
    <content type="html"><![CDATA[<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p>代码仓库中有个 packages 目录，里面主要是 Vue 3 的主要功能实现。  </p><ul><li>reactivity 目录：数据响应式系统，这是一个单独的系统，可以与任何框架配合使用。</li><li>runtime-core 目录：与平台无关的运行时。其实现的功能有虚拟 DOM 渲染器、Vue 组件和 Vue 的各种API，我们可以利用这个 runtime 实现针对某个具体平台的高阶 runtime，比如自定义渲染器。</li><li>runtime-dom 目录: 针对浏览器的 runtime。其功能包括处理原生 DOM API、DOM 事件和 DOM 属性等。</li><li>runtime-test 目录: 一个专门为了测试而写的轻量级 runtime。由于这个 rumtime 「渲染」出的 DOM 树其实是一个 JS 对象，所以这个 runtime 可以用在所有 JS 环境里。你可以用它来测试渲染是否正确。它还可以用于序列化 DOM、触发 DOM 事件，以及记录某次更新中的 DOM 操作。</li><li>server-renderer 目录: 用于 SSR，尚未实现。</li><li>compiler-core 目录: 平台无关的编译器，它既包含可扩展的基础功能，也包含所有平台无关的插件。</li><li>compiler-dom 目录: 针对浏览器的编译器。</li><li>shared 目录: 没有暴露任何 API，主要包含了一些平台无关的内部帮助方法。</li><li>vue 目录: 用于构建「完整」版本，引用了上面提到的 runtime 和 compiler目录。  </li></ul><p>关于阅读顺序，我的建议是</p><p>先读 reactivity，能最快了解 Vue 3 的新特性；<br>再读 rumtime，理解组件和生命周期的实现；<br>如果还有时间再读 compiler，理解编译优化过程。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;项目结构&quot;&gt;&lt;a href=&quot;#项目结构&quot; class=&quot;headerlink&quot; title=&quot;项目结构&quot;&gt;&lt;/a&gt;项目结构&lt;/h3&gt;&lt;p&gt;代码仓库中有个 packages 目录，里面主要是 Vue 3 的主要功能实现。  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;reacti
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PhotoShop CC Web切图界面设置</title>
    <link href="https://mrdouhua.github.io/2020/06/30/PhotoShop%20CC%20Web%E5%88%87%E5%9B%BE%E7%95%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE/"/>
    <id>https://mrdouhua.github.io/2020/06/30/PhotoShop%20CC%20Web%E5%88%87%E5%9B%BE%E7%95%8C%E9%9D%A2%E8%AE%BE%E7%BD%AE/</id>
    <published>2020-06-30T02:14:24.241Z</published>
    <updated>2020-06-30T02:14:56.094Z</updated>
    
    <content type="html"><![CDATA[<ul><li>界面为移动工具时（快捷键V），选中左上角的图层。</li><li>点击视图，选中显示→智能参考线，与标尺。</li><li>点击窗口，把“库” “颜色”去掉，把屏幕右上角的“通道” “路径”关闭，旁边的“属性”关闭，选中“图层” “信息” “字符”。把“信息” “字符”，里面的“段落”，“属性”关闭。</li><li>单击信息右边的按钮，选着面板选项，第一颜色选择RGB，下面选上文档大小。</li><li>单击编辑，选择最下面的首选项→单位与标尺，文字→像素</li><li>窗口→工作区→新建工作区，取名Web切图，选择键盘快捷键与菜单，保存。→→这是为了保存刚才的设置。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;界面为移动工具时（快捷键V），选中左上角的图层。&lt;/li&gt;
&lt;li&gt;点击视图，选中显示→智能参考线，与标尺。&lt;/li&gt;
&lt;li&gt;点击窗口，把“库” “颜色”去掉，把屏幕右上角的“通道” “路径”关闭，旁边的“属性”关闭，选中“图层” “信息” “字符”。把“信息
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSS3 过度与动画</title>
    <link href="https://mrdouhua.github.io/2020/06/30/CSS3%20%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB/"/>
    <id>https://mrdouhua.github.io/2020/06/30/CSS3%20%E8%BF%87%E5%BA%A6%E4%B8%8E%E5%8A%A8%E7%94%BB/</id>
    <published>2020-06-30T01:56:19.888Z</published>
    <updated>2020-07-07T06:59:31.431Z</updated>
    
    <content type="html"><![CDATA[<p>CSS3的过度模块挺好用的，可以让一个属性在两个状态之间移动的动画。</p><h2 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h2><p>transform设置形状</p><ul><li>translate</li><li>scale</li><li>rotate</li><li>skew 倾斜<h2 id="Transition"><a href="#Transition" class="headerlink" title="Transition"></a>Transition</h2>Transition是一种直观上的效果，让DOM元素的某个属性在固定时间内从一旧值到一新值。</li></ul><h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><p>Internet Explorer 10、Firefox、Chrome 以及 Opera 支持 transition 属性。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">background:red;</span><br><span class="line">transition:width 2s;</span><br><span class="line">-moz-transition:width 2s; &#x2F;* Firefox 4 *&#x2F;</span><br><span class="line">-webkit-transition:width 2s; &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">-o-transition:width 2s; &#x2F;* Opera *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">div:hover</span><br><span class="line">&#123;</span><br><span class="line">width:300px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/2015490-009b1ea32ce21f77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"><br><strong>transition-timing-function</strong><br>既然是动画，那么就有动画的运行速率，不同的速度会产生不同的结果，以下是可取值。<br>ease：（逐渐变慢）默认值，ease函数等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0).<br>linear：（匀速），linear 函数等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0).<br>ease-in：(加速)，ease-in 函数等同于贝塞尔曲线(0.42, 0, 1.0, 1.0).<br>ease-out：（减速），ease-out 函数等同于贝塞尔曲线(0, 0, 0.58, 1.0).<br>ease-in-out：（加速然后减速），ease-in-out 函数等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)</p><h3 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h3><p>简写的 transition 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transition: transition-property transition-duration transition-timing-function transition-delay</span><br></pre></td></tr></table></figure><h2 id="关键帧"><a href="#关键帧" class="headerlink" title="关键帧"></a>关键帧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@keyframes &#39;name&#39; &#123;</span><br><span class="line">    keyframe &#123;</span><br><span class="line">    property: value;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><strong>匀速向下移动:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mymove</span><br><span class="line">&#123;</span><br><span class="line">from &#123;top:0px;&#125;</span><br><span class="line">to &#123;top:200px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes mymove &#x2F;* Firefox *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">from &#123;top:0px;&#125;</span><br><span class="line">to &#123;top:200px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes mymove &#x2F;* Safari 和 Chrome *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">from &#123;top:0px;&#125;</span><br><span class="line">to &#123;top:200px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-o-keyframes mymove &#x2F;* Opera *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">from &#123;top:0px;&#125;</span><br><span class="line">to &#123;top:200px;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。<br>在一个动画中添加多个 keyframe 选择器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">@keyframes mymove</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">25%  &#123;top:200px;&#125;</span><br><span class="line">50%  &#123;top:100px;&#125;</span><br><span class="line">75%  &#123;top:200px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-moz-keyframes mymove &#x2F;* Firefox *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">25%  &#123;top:200px;&#125;</span><br><span class="line">50%  &#123;top:100px;&#125;</span><br><span class="line">75%  &#123;top:200px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-webkit-keyframes mymove &#x2F;* Safari 和 Chrome *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">25%  &#123;top:200px;&#125;</span><br><span class="line">50%  &#123;top:100px;&#125;</span><br><span class="line">75%  &#123;top:200px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-o-keyframes mymove &#x2F;* Opera *&#x2F;</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;top:0px;&#125;</span><br><span class="line">25%  &#123;top:200px;&#125;</span><br><span class="line">50%  &#123;top:100px;&#125;</span><br><span class="line">75%  &#123;top:200px;&#125;</span><br><span class="line">100% &#123;top:0px;&#125;</span><br><span class="line">&#125;</span><br><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">width:100px;</span><br><span class="line">height:100px;</span><br><span class="line">background:red;</span><br><span class="line">position:relative;</span><br><span class="line">animation:mymove 5s infinite;</span><br><span class="line">-moz-animation:mymove 5s infinite; &#x2F;* Firefox *&#x2F;</span><br><span class="line">-webkit-animation:mymove 5s infinite; &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">-o-animation:mymove 5s infinite; &#x2F;* Opera *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然还可以添加这些<strong>动画属性</strong><br><strong>名称：</strong>animation-name</p><p><strong>持续时间：</strong>animation-duration</p><p><strong>计时函数：</strong>animation-timing-function<br>animation-timing-function:ease | linear | ease-in | ease-out | ease-in-out</p><p><strong>延迟：</strong>animation-delay</p><p><strong>迭代次数：</strong>animation-iteration-count<br>animation-iteration-count是用来指定元素播放动画的循环次数，其可以取值<number>为数字，其默认值为“1”；infinite为无限次数循环。</p><p><strong>播放状态：</strong>animation-play-state<br>其主要有两个值，running和paused</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSS3的过度模块挺好用的，可以让一个属性在两个状态之间移动的动画。&lt;/p&gt;
&lt;h2 id=&quot;transform&quot;&gt;&lt;a href=&quot;#transform&quot; class=&quot;headerlink&quot; title=&quot;transform&quot;&gt;&lt;/a&gt;transform&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CSS3 2D</title>
    <link href="https://mrdouhua.github.io/2020/06/30/CSS3%202D/"/>
    <id>https://mrdouhua.github.io/2020/06/30/CSS3%202D/</id>
    <published>2020-06-30T01:56:19.272Z</published>
    <updated>2020-06-30T02:00:40.535Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3-2D转换"><a href="#CSS3-2D转换" class="headerlink" title="CSS3 2D转换"></a>CSS3 2D转换</h2><p>CSS3转换，我们可以移动，比例化，反过来，旋转，和拉伸元素。</p><ul><li>translate()</li><li>rotate()</li><li>scale()</li><li>skew()</li><li>matrix()</li></ul><h3 id="translate-方法"><a href="#translate-方法" class="headerlink" title="translate() 方法"></a>translate() 方法</h3><p>translate()方法，根据左(X轴)和顶部(Y轴)位置给定的参数，从当前元素位置移动。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: translate(50px,100px);</span><br><span class="line">-ms-transform: translate(50px,100px); &#x2F;* IE 9 *&#x2F;</span><br><span class="line">-webkit-transform: translate(50px,100px); &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>translateX(n)    定义 2D 转换，沿着 X 轴移动元素。</li><li>translateY(n)    定义 2D 转换，沿着 Y 轴移动元素。</li></ul><h3 id="rotate-方法"><a href="#rotate-方法" class="headerlink" title="rotate() 方法"></a>rotate() 方法</h3><p>rotate()方法，在一个给定度数顺时针旋转的元素。负值是允许的，这样是元素逆时针旋转。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">div</span><br><span class="line">&#123;</span><br><span class="line">transform: rotate(30deg);</span><br><span class="line">-ms-transform: rotate(30deg); &#x2F;* IE 9 *&#x2F;</span><br><span class="line">-webkit-transform: rotate(30deg); &#x2F;* Safari and Chrome *&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="scale-方法"><a href="#scale-方法" class="headerlink" title="scale() 方法"></a>scale() 方法</h3><p>scale()方法，该元素增加或减少的大小，取决于宽度（X轴）和高度（Y轴）的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; scale（2,3）转变宽度为原来的大小的2倍，和其原始大小3倍的高度。</span><br><span class="line">-ms-transform:scale(2,3); &#x2F;* IE 9 *&#x2F;</span><br><span class="line">-webkit-transform: scale(2,3); &#x2F;* Safari *&#x2F;</span><br><span class="line">transform: scale(2,3); &#x2F;* 标准语法 *&#x2F;</span><br></pre></td></tr></table></figure><h3 id="skew-方法"><a href="#skew-方法" class="headerlink" title="skew() 方法"></a>skew() 方法</h3><p>包含两个参数值，分别表示X轴和Y轴倾斜的角度，如果第二个参数为空，则默认为0，参数为负表示向相反方向倾斜。</p><ul><li>skewX(<angle>);表示只在X轴(水平方向)倾斜。</li><li>skewY(<angle>);表示只在Y轴(垂直方向)倾斜。</li></ul><h3 id="matrix-方法"><a href="#matrix-方法" class="headerlink" title="matrix() 方法"></a>matrix() 方法</h3><p>matrix()方法把2D变换方法合并成一个。<br>matrix 方法有六个参数，包含旋转，缩放，移动（平移）和倾斜功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS3-2D转换&quot;&gt;&lt;a href=&quot;#CSS3-2D转换&quot; class=&quot;headerlink&quot; title=&quot;CSS3 2D转换&quot;&gt;&lt;/a&gt;CSS3 2D转换&lt;/h2&gt;&lt;p&gt;CSS3转换，我们可以移动，比例化，反过来，旋转，和拉伸元素。&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Web Workers实现javascript多线程</title>
    <link href="https://mrdouhua.github.io/2020/06/30/Web%20Workers%E5%AE%9E%E7%8E%B0javascript%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://mrdouhua.github.io/2020/06/30/Web%20Workers%E5%AE%9E%E7%8E%B0javascript%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-06-30T01:56:18.641Z</published>
    <updated>2020-06-30T02:00:26.084Z</updated>
    
    <content type="html"><![CDATA[<p>大家可能都知道javascript是单线程。但在HTML5中新增与线程相关的一个API，Web Workers可以实现Web平台上多线程处理的功能。Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。</p><p>我们需要把希望单独执行的javascript代码放到一个单独的js文件中，然后在页面中调用Worker构造函数来创建一个线程，参数是该文件路径，参数存放如果是相对地址，那么要以包含调用Worker构造函数语句所在脚本为参照，如果是绝对路径，需要保证同源（协议+主机+端口）。这个文件不需要我们在页面使用script标签显示引用</p><p>创建一个新的 worker 十分简单。你所要做的就是调用 Worker() 构造函数，指定一个要在 worker 线程内运行的脚本的 URI</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myWorker &#x3D; new Worker(&quot;my_task.js&quot;);</span><br><span class="line"></span><br><span class="line">myWorker.onmessage &#x3D; function (oEvent) &#123;</span><br><span class="line">  console.log(&quot;Called back by the worker!\n&quot;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者，你也可以使用 addEventListener()：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myWorker &#x3D; new Worker(&quot;my_task.js&quot;);</span><br><span class="line"></span><br><span class="line">myWorker.addEventListener(&quot;message&quot;, function (oEvent) &#123;</span><br><span class="line">  console.log(&quot;Called back by the worker!\n&quot;);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">myWorker.postMessage(&quot;&quot;); &#x2F;&#x2F; start the worker.</span><br></pre></td></tr></table></figure><p>worker对象只有两个<strong>属性</strong></p><ul><li>onerror:当worker运行出现错误，并且没有在worker中ing捕获，会在此捕获</li><li>onmessage:当worker向主线程发送消息是调用</li></ul><p>在其prototype内有两个重要<strong>方法</strong></p><ul><li><strong>postMessage</strong>:很熟悉的赶脚，之前我们介绍过window对象的postMessage()方法，woker的postMessage方法和window的比较类似，但参数略有不同，只需要传递消息内容就可以，而且支持所有JavaScript原生数据类型，当然不放心的话同样也可以序列化为字符串传递</li><li><strong>terminate</strong>:终止worker执行，有些worker执行比较慢，主线程可以主动终止其执行</li></ul><p><strong>worker.onmessage</strong><br>在这个句柄内接收外部调用者传递的参数，参数可以通过e.data获取。即获取子线程中postMessage时方法传来的数据。</p><p>在worker中不能使用window对象和docuemnt对象。<br>但可以使用这些：</p><ul><li>JavaScript的全局对象：JSON、Date()、Array</li><li>self自身引用</li><li>location对象，但是其属性都是只读的，改了也影响不到调用者</li><li>navigator对象</li><li>setTimeout()、setInterval()及其对应清除方法</li><li>addEventListener()、removeEventListener()</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大家可能都知道javascript是单线程。但在HTML5中新增与线程相关的一个API，Web Workers可以实现Web平台上多线程处理的功能。Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面。&lt;/p&gt;
&lt;p&gt;我
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>浅谈html5 WebRTC（待跟新）</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E6%B5%85%E8%B0%88html5%20WebRTC%EF%BC%88%E5%BE%85%E8%B7%9F%E6%96%B0%EF%BC%89/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E6%B5%85%E8%B0%88html5%20WebRTC%EF%BC%88%E5%BE%85%E8%B7%9F%E6%96%B0%EF%BC%89/</id>
    <published>2020-06-30T01:56:18.019Z</published>
    <updated>2020-06-30T02:00:10.196Z</updated>
    
    <content type="html"><![CDATA[<p>WebRTC，名称源自网页实时通信（Web Real-Time Communication）的缩写,它主要用来让浏览器实时获取和交换视频、音频和数据。</p><p>在两个浏览器之间为了通信、游戏或文件传输而发送数据是一个非常复杂的过程，因为需要搭建服务器，还可能需要配置数据中心，也很难保证数据的私密性。<br>但这些问题在WebRTc中的RTCDataChannel API中得到减缓，因为可以直接将数据从一个浏览器发送到另外一个浏览器。</p><p>WebRTC共分三个API。</p><ul><li>MediaStream（又称getUserMedia）</li><li>RTCPeerConnection</li><li>RTCDataChannel</li></ul><h2 id="getUserMedia"><a href="#getUserMedia" class="headerlink" title="getUserMedia"></a>getUserMedia</h2><p>getUserMedia方法接受三个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getUserMedia(streams, success, error);</span><br></pre></td></tr></table></figure><ul><li>streams：表示包括哪些多媒体设备的对象</li><li>success：回调函数，获取多媒体设备成功时调用</li><li>error：回调函数，获取多媒体设备失败时调用</li><li><em>例子：*</em><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">navigator.getUserMedia(&#123;</span><br><span class="line">    video: true,</span><br><span class="line">    audio: true</span><br><span class="line">&#125;, onSuccess, onError);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;WebRTC，名称源自网页实时通信（Web Real-Time Communication）的缩写,它主要用来让浏览器实时获取和交换视频、音频和数据。&lt;/p&gt;
&lt;p&gt;在两个浏览器之间为了通信、游戏或文件传输而发送数据是一个非常复杂的过程，因为需要搭建服务器，还可能需要配置数
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>html5 通信API(跟新中)</title>
    <link href="https://mrdouhua.github.io/2020/06/30/html5%20%E9%80%9A%E4%BF%A1API(%E8%B7%9F%E6%96%B0%E4%B8%AD)/"/>
    <id>https://mrdouhua.github.io/2020/06/30/html5%20%E9%80%9A%E4%BF%A1API(%E8%B7%9F%E6%96%B0%E4%B8%AD)/</id>
    <published>2020-06-30T01:56:17.352Z</published>
    <updated>2020-06-30T02:00:00.607Z</updated>
    
    <content type="html"><![CDATA[<p>HTML5种新增与通信相关的三个功能</p><ul><li>跨文档消息传输功能<br>可以在不同网页、不同端口、不同域之间进行消息的传递</li><li>使用WebSockets API来通过socket端口传递数据的功能<br>可以让客户端与服务器端通过socket端口来传输数据</li><li>通过Server-Sent Events API将服务器端事件主动推送到客户端的功能<br>服务器端可以每隔一段时间主动向客户端发送一个携带数据的事件</li></ul><h2 id="跨文档消息传输"><a href="#跨文档消息传输" class="headerlink" title="跨文档消息传输"></a>跨文档消息传输</h2><p>HTML5提供了在网页文档之间互相接受与发送信息的功能，只要获取到网页所在窗口对象的实例，同源（域+端口号）的Web网页之间可以互相通信，也可以实现跨域通信。 </p><p><strong>发送</strong><br>使用window对象的postMessage方法向其他窗口发送消息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">otherWindow.postMessage(message,targetOrign);</span><br></pre></td></tr></table></figure><p>该方法使用两个参数，第一个参数为所发送的消息文本，但也可以是任何JavaScript对象（通过JSON转换对象为文本）;第二个参数为接收消息的对象窗口的URL地址。</p><p><strong>接受</strong><br>接受从其他窗口那里发过来的消息，需要对窗口对象的message事件进行监视</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&quot;message&quot;,function()&#123;...&#125;,false);</span><br></pre></td></tr></table></figure><h2 id="通道通信"><a href="#通道通信" class="headerlink" title="通道通信"></a>通道通信</h2><p>通道通信提供了一种在多个源之间进行通信的方法，这些源之间通过端口进行通信。<br>目前只有chrome支持通道通信机制。</p><h2 id="WebSockets-通信"><a href="#WebSockets-通信" class="headerlink" title="WebSockets 通信"></a>WebSockets 通信</h2><p>WebSocket API是下一代客户端-服务器的异步通信方法。也是是Html5提供的在Web应用程序中客户端与服务器端之间进行的非HTTP的通信机制。<br>WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。WebSocket并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；XHR受到域的限制，而WebSocket允许跨域通信。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HTML5种新增与通信相关的三个功能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;跨文档消息传输功能&lt;br&gt;可以在不同网页、不同端口、不同域之间进行消息的传递&lt;/li&gt;
&lt;li&gt;使用WebSockets API来通过socket端口传递数据的功能&lt;br&gt;可以让客户端与服务器端通过socket
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>扩展的XMLHttpRequest API</title>
    <link href="https://mrdouhua.github.io/2020/06/30/%E6%89%A9%E5%B1%95%E7%9A%84XMLHttpRequest%20API/"/>
    <id>https://mrdouhua.github.io/2020/06/30/%E6%89%A9%E5%B1%95%E7%9A%84XMLHttpRequest%20API/</id>
    <published>2020-06-30T01:56:16.721Z</published>
    <updated>2020-06-30T01:59:30.052Z</updated>
    
    <content type="html"><![CDATA[<p>随着HTML5的到来，XMLHttpRequest API中新增了关于跨域请求、进度时间的上传、二进制数据的上传及下载等许多功能。</p><h3 id="从服务器获取二进制数据"><a href="#从服务器获取二进制数据" class="headerlink" title="从服务器获取二进制数据"></a>从服务器获取二进制数据</h3><p>在HTML5之前，从服务器获取二进制数据，需要设置XMLHttpRequest对象的overrideMimeType方法，以此重载数据的Mime Type类型，用户自定义数据的字符编码类型。但这样有个缺点，responseText返回的并不是原始的二进制数据，而是一串字符串。<br>在HTML5中，新增了responseType属性与response属性来解决这个问题。<br><strong>responseType</strong><br>指定服务器返回数据的数据类型，text、arraybuffer、blob、json与document。<br><strong>response</strong><br>如果请求服务器成功，response属性值返回服务器响应的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">BlobBuilder&#x3D; window.MozBlobBuilder||</span><br><span class="line"> window.WebKitBlobBuilder||</span><br><span class="line"> window.BlobBuilder;</span><br><span class="line">var xhr &#x3D;newXMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;,&#39;&#x2F;path&#x2F;to&#x2F;image.png&#39;,true);</span><br><span class="line">xhr.responseType &#x3D;&#39;arraybuffer&#39;;</span><br><span class="line">xhr.onload&#x3D;function(e)&#123;</span><br><span class="line">    if(this.status &#x3D;&#x3D;200)&#123;var bb &#x3D;newBlobBuilder();</span><br><span class="line">    bb.append(this.response);&#x2F;&#x2F; Note: not xhr.responseTextvar blob &#x3D; bb.getBlob(&#39;image&#x2F;png&#39;);...</span><br><span class="line">&#125;&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h3 id="ArrayBuffer"><a href="#ArrayBuffer" class="headerlink" title="ArrayBuffer"></a>ArrayBuffer</h3><p>ArrayBuffer 是二进制数据通用的固定长度容器。当responseType属性值为ArrayBuffer时，服务器端将会返回一个ArrayBuffer对象。</p><h3 id="Blob-响应"><a href="#Blob-响应" class="headerlink" title="Blob 响应"></a>Blob 响应</h3><p>当不需要修改从服务器端下载的二进制数据时，除了设置为ArrayBuffer外，还可以将responseType属性值为blob。</p><h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>HTML5之前，大多数浏览器只能通过send方法字符串或Document对象。<br>在HTML5中，可接受以下任何类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOMString、Document、FormData、Blob、File、ArrayBuffer</span><br></pre></td></tr></table></figure><h3 id="发送字符串数据：xhr-send-DOMString"><a href="#发送字符串数据：xhr-send-DOMString" class="headerlink" title="发送字符串数据：xhr.send(DOMString)"></a>发送字符串数据：xhr.send(DOMString)</h3><p>设置 responseType=’text’</p><h3 id="发送表单数据：xhr-send-FormData"><a href="#发送表单数据：xhr-send-FormData" class="headerlink" title="发送表单数据：xhr.send(FormData)"></a>发送表单数据：xhr.send(FormData)</h3><p>html表单enctype属性设置multipart/form-data，input设置name属性。然后js里构建FormData对象。<br><strong>js</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var formData&#x3D;new FormData(myform);</span><br><span class="line">formData.append(&#39;username&#39;,&#39;johndoe&#39;);</span><br><span class="line">formData.append(&#39;id&#39;,123456);</span><br><span class="line">var xhr &#x3D;newXMLHttpRequest();</span><br><span class="line">  xhr.open(&#39;POST&#39;,&#39;&#x2F;server&#39;,true);</span><br><span class="line">  xhr.onload &#x3D;function(e)&#123;...&#125;;</span><br><span class="line">  xhr.send(formData);</span><br></pre></td></tr></table></figure><p><strong>html</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id&#x3D;&quot;myform&quot; name&#x3D;&quot;myform&quot; action&#x3D;&quot;&#x2F;server&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; value&#x3D;&quot;johndoe&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;number&quot; name&#x3D;&quot;id&quot; value&#x3D;&quot;123456&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; onclick&#x3D;&quot;return sendForm(this.form);&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>上传文件也是通过构建FormData对象，上传方法与上述相似。</p><h3 id="上传Blob对象"><a href="#上传Blob对象" class="headerlink" title="上传Blob对象"></a>上传Blob对象</h3><p>所有File对象都是一个Blob对象，因此可以通过发送Blob对象的方法来上传文件。<br>当需要显示上传进度时，通过Blob对象也十分适合。<br>但目前只有Chrome浏览器支持上传数据（不限于Blob对象）的同时同步跟新进度条控件中所显示的进度。</p><h3 id="跨域数据请求"><a href="#跨域数据请求" class="headerlink" title="跨域数据请求"></a>跨域数据请求</h3><p>在HTML5以前，通过ajax不能跨域，在HTML5中，由于支持跨域数据通信，所以可以实现跨域数据请求。<br>跨域需要服务器启用CORS，如果服务器端已启用了 CORS，那么提交跨域请求就和普通的 XMLHttpRequest 请求没什么区别。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着HTML5的到来，XMLHttpRequest API中新增了关于跨域请求、进度时间的上传、二进制数据的上传及下载等许多功能。&lt;/p&gt;
&lt;h3 id=&quot;从服务器获取二进制数据&quot;&gt;&lt;a href=&quot;#从服务器获取二进制数据&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>call、apply、bind区别与用法</title>
    <link href="https://mrdouhua.github.io/2020/06/30/call%E3%80%81apply%E3%80%81bind%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E6%B3%95/"/>
    <id>https://mrdouhua.github.io/2020/06/30/call%E3%80%81apply%E3%80%81bind%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E6%B3%95/</id>
    <published>2020-06-30T01:56:16.071Z</published>
    <updated>2020-06-30T01:59:22.716Z</updated>
    
    <content type="html"><![CDATA[<p>call与apply方法都是改变函数体内的this指向，即改变函数运行时的上下文。若没有什么对象调用这个方法，所以第一个参数可以写作null或者本身；</p><p>在call与apply方法中，第一个参数就是this的指向，但apply第二个参数是一个数组，call第二个及以后直接是数组中里面的元素。</p><p><strong>call与apply常用法</strong></p><ul><li>数组之间的追加</li><li>获取数组中的最大值和最小值，利用Math的min和max方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [1,2,3,4];</span><br><span class="line">Math.max.apply(null, arr) &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure></li><li>验证是否是数组（前提是toString（）方法没有被重写过）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function   isArray(obj)&#123; </span><br><span class="line">    return Object.prototype.toString.call(obj) &#x3D;&#x3D;&#x3D; &#39;[object Array]&#39; ; &#x2F;&#x2F; true or false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>bind()也是改变函数体内this的指向，bind会创建一个新函数，该函数不会立即执行，需要自己手动调用执行。</p><p>三个的使用<strong>区别</strong></p><ul><li>都是用来改变函数的this对象的指向的</li><li>第一个参数都是this要指向的对象</li><li>都可以利用后续参数传参</li><li>bind是返回对应函数，便于稍后调用，apply、call是立即调用</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;call与apply方法都是改变函数体内的this指向，即改变函数运行时的上下文。若没有什么对象调用这个方法，所以第一个参数可以写作null或者本身；&lt;/p&gt;
&lt;p&gt;在call与apply方法中，第一个参数就是this的指向，但apply第二个参数是一个数组，call第二个
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
